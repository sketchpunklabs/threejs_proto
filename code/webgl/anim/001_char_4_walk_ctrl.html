<!DOCTYPE html><html lang="en"><head><title></title></head>
<style>canvas{ display:block; } body, html { padding:0px; margin:0px; width:100%; height:100%; }</style>
<body><script src="../../../import-map.js"></script><script type="module">
// #region IMPORTS
    import useThreeWebGL2, { THREE, useDarkScene, useVisualDebug } from '@lib/useThreeWebGL2.js';
    import { GLTFLoader } from 'three/GLTFLoader.js';
    import * as util    from '@lib/util.js';

    import Vec3             from '@lib/maths/Vec3.js';
    import Quat             from '@lib/maths/Quat.js';
    import Radian           from '@lib/maths/Radian.js';
    import FImplicitEuler   from '@lib/maths/springs/FImplicitEuler.js';

    import { Pane }         from '@tp/tweakpane/tweakpane-4.0.4.min.js';

    import KeyboardInput        from '@lib/input/KeyboardInput.js';
    import Cursor3DMaterial     from '@lib/shader/Cursor3DMaterial.js';
// #endregion

// #region MAIN
    let App   = useDarkScene( useThreeWebGL2() );
    let Debug = {};
    let Ref   = {};

    window.addEventListener( 'load', async ()=>{
    	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    	App.sphericalLook( 0, 20, 5, [0,1.0,0] );
        Debug   = await useVisualDebug( App );
        Ref.ki  = new KeyboardInput();

        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        // LOAD CHAR & ANIMATION
        const url   = '../../../res/models/mewtwo/';
        const [ [ charRoot, skinned ], aryAnim ] = await Promise.all([
            loadCharacter( { url: `${url}/mewtwo.gltf`, toon:true } ), //, phong:0xffffff
            loadAnimations( `${url}/anim_land_traverse.gltf` ),
        ]);

        // aryAnim.forEach( i=>console.log( i.name ) );
        const skel  = skinned.skeleton;

        const cIdle = aryAnim.find( i=>(i.name==='defaultidle01') ); //defaultwait_loop
        const cWalk = aryAnim.find( i=>(i.name==='walk_loop') );
        const cRun  = aryAnim.find( i=>(i.name==='run_loop') );

        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        //  SETUP BLEND SPACE
        const blendSpace = new BlendSpace1D( skel, 'origin' );
        blendSpace
            .addClip( cIdle )
            .addClip( cWalk )
            .addClip( cRun, 0.53 ); // Offset to make the left foot match, needed for good blending

        blendSpace.blend = 0;

        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        Ref.ctrl = new Controller();
        Ref.ctrl.root.add(
            Cursor3DMaterial.createMesh( {factor:0, color:'#d0d0d0'} ),
            charRoot,
        );

        Ref.ctrl.anim = blendSpace;
        App.scene.add( Ref.ctrl.root );

        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        App.createRenderLoop( onPreRender ).start();
        // App.renderLoop();
        appendGithubLink( false );
    });

    function onPreRender( dt, et ){
        // Debug.reset();
        Ref.ctrl.update( dt, App.camera, Ref.ki );
    }
// #endregion

// #region LOADING
    async function loadCharacter( props={} ){
        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        // LOAD
        const opt = { skel:true, skelHelper:false, phong:undefined, toon:false, tpose:false, ...props };
        const tf  = await new GLTFLoader().loadAsync( opt.url );
        // const o  = firstFind( tf.scene, o=> (o.type === 'SkinnedMesh') );

        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        // Find Skeleton & Push Skinned Meshes to the scene
        // let skel;
        let skinned;
        let mat = null;
        for( const m of util.traverseFind( tf.scene, o=> (o.type === 'SkinnedMesh') ) ){
            if( opt.phong != null ) mat = new THREE.MeshPhongMaterial( { color: opt.phong } );
            if( opt.toon ) mat = new THREE.MeshToonMaterial( { map: m.material.map, normalMap: m.material.normalMap } );

            if( mat )       m.material = mat;
            // if( !skel )     skel = m.skeleton;  // First skeleton
            if( !skinned )  skinned = m;  // First skeleton
        }

        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        if( opt.tpose ){
            const clip = tf.animations.find( i=>i.name.toLowerCase() === 'tpose' );
            if( clip )  util.poseFromClip( clip, skel );
            else        console.log( 'TPose animation clip not found' );
        }

        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        // Push Skeleton Helper
        // App.scene.add( skel.bones[0] );
        if( opt.skelHelper ){
            App.scene.add( new THREE.SkeletonHelper( skel.bones[0] ) );
        }

        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        return [ tf.scene, skinned ];
    }

    async function loadAnimations( url ){
        const tf = await new GLTFLoader().loadAsync( url );
        return tf.animations ?? [];
    }
// #endregion

// #region BLEND SPACE 1D
    class BlendSpaceItem{
        constructor( act, tOff, rName ){
            this.action      = act;
            this.timeOffset  = tOff;
            this.rootMotion  = new RootMotion( act, rName );
        }
    }

    class BlendSpace1D{
        mixer       = new THREE.AnimationMixer( new THREE.Object3D() );
        rootName    = '';           // Bone Name that supplies root motion
        boneIdx     = -1;           // Index to root motion bone
        skel        = null;         // Skeleton that animation gets applied to
        stack       = new Array();  // Animation Stack
        #blend      = 0;            // Blend value
        velocity    = new Vec3();   // Root motion velocity results

        constructor( skel, rName ){
            this.skel     = skel;
            this.rootName = rName;
            this.boneIdx  = skel.bones.findIndex( i=>( i.name === rName ) );
        }

        addClip( clip, timeOffset=0, root=null ){
            const act = this.mixer.clipAction( clip, root || this.skel.bones[0] );
            act.enabled = false;

            const itm = new BlendSpaceItem( act, timeOffset, this.rootName );
            this.stack.push( itm );

            return this;
        }

        // #region GETTERS / SETTERS
        set blend( v ){
            // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            // Compute Weights between two actions
            const max   = this.stack.length - 1;
            let bi      = 0;                // Index to 2nd Action
            let ai      = Math.floor( v );  // Index to 1st Action
            let bt      = v - ai;           // Weight for 2nd Action
            let at      = 0;                // Weight for 1st Action

            if( ai >= max ){        // If over, default to fully weighted final action
                ai = bi = max;
                at = bt = 1;
            }else{
                bi = ai + 1;
                at = 1.0 - bt;
            }

            this.#blend = v;
            // console.log( 'Idx', ai, 'T', at, 'bIdx', bi, 'T', bt );

            // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            const a = this.stack[ ai ];
            const b = this.stack[ bi ];

            // console.log( a.action._clip.name, b.action._clip.name );

            if( ai === bi ){
                // -----------------------------
                // Single action
                a.action.enabled = true;
                a.action.setEffectiveTimeScale( 1 );
                a.action.setEffectiveWeight( 1 );
                a.action.play();

                a.rootMotion.reset();
            }else{
                // console.log( a.action.enabled, b.action.enabled, a.timeOffset, b.timeOffset );
                // Set time for newly activated action
                if( a.action.enabled && !b.action.enabled ){
                    // -----------------------------
                    // Blend B into A
                    b.action.reset();
                    b.rootMotion.reset();

                    console.log( 'B to A' );

                    const time    = ( a.action.time - a.timeOffset ) % a.action._clip.duration;
                    const ratio   = time / a.action._clip.duration;
                    b.action.time = b.action._clip.duration * ratio + b.timeOffset;

                }else if( !a.action.enabled && b.action.enabled ){
                    // -----------------------------
                    // Blend A Into B
                    a.action.reset();
                    a.rootMotion.reset();
                    console.log( 'A to B' );

                    const time    = ( b.action.time - b.timeOffset ) % b.action._clip.duration;
                    const ratio   = time / b.action._clip.duration;
                    a.action.time = a.action._clip.duration * ratio + a.timeOffset;

                }else if( !a.action.enabled && !b.action.enabled ){
                    // -----------------------------
                    // No blending, start at the same time
                    console.log( 'RESET BOTH' );
                    a.action.reset();
                    a.rootMotion.reset();

                    b.action.reset();
                    b.rootMotion.reset();

                    a.action.time = a.timeOffset;
                    b.action.time = b.timeOffset;
                }

                // -----------------------------
                // Compute weight sync with time scale
                const dur  = a.action._clip.duration * at +
                             b.action._clip.duration * bt;      // Get Weighted Duration
                const aScl = a.action._clip.duration / dur;     // Calc scale for each weighted action
                const bScl = b.action._clip.duration / dur;

                // Set 1st Action
                a.action.enabled = true;
                a.action.setEffectiveTimeScale( aScl );
                a.action.setEffectiveWeight( at );
                a.action.play();

                // Set 2nd Action
                b.action.enabled = true;
                b.action.setEffectiveTimeScale( bScl );
                b.action.setEffectiveWeight( bt );
                b.action.play();

                // -----------------------------
                // Need to reset root motions with correct time & starting position
                a.rootMotion.resetPos();
                b.rootMotion.resetPos();
            }

            // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            // Disable actions
            for( const [i,e] of this.stack.entries() ){
                if( i !== ai && i !== bi ){
                    e.action.enabled = false;
                    // e.action.stop();
                    // console.log( 'stop', e.action._clip.name );
                }
            }
        }
        // #endregion

        // Main Update to run mixer
        update( dt ){
            this.mixer.update( dt );    // Create next frame
            this.updateRootMotion();    // Compute motion of root since last update
            this.applyInPlace();        // Clear XZ Plane
        }

        applyInPlace(){
            const b = this.skel.bones[ this.boneIdx ];
            b.position.x = 0;
            b.position.z = 0;
        }

        // Process & Blend Root Motion Velocity
        updateRootMotion(){
            const v = new Vec3();
            let wgt = 0;
            this.velocity.xyz(0,0,0);

            for( let i of this.stack ){
                // Skip distabled actions or actions with no weight
                if( i.action.enabled && ( wgt = i.action.getEffectiveWeight() ) > 0 ){
                    i.rootMotion.update();
                    v.fromScale( i.rootMotion.velocity, wgt );
                    this.velocity.add( v );
                }
            }
        }
    }
// #endregion

// #region ROOT MOTION
    // NOTE: action._interpolants[].resultBuffer can not be trusted with the correct final data
    // Compute the frame blended vec3 position of a clip track using action timing
    function actionFramePosition( act, trackIdx, out=[0,0,0] ){
        const clip = act._clip;
        const trk  = clip.tracks[ trackIdx ];
        const iMax = trk.times.length - 1;      // Make Frame Index

        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        // Find which frame animation is currently on
        let ai = 0;
        let bi = 1;
        for( let i=iMax; i > 0; i-- ){
            if( act.time >= trk.times[i] ){
                ai = i;
                bi = i+1;
                break;
            }
        }

        if( ai >= iMax ){
            out[ 0 ] = trk.values[ ai + 0 ];
            out[ 1 ] = trk.values[ ai + 1 ];
            out[ 2 ] = trk.values[ ai + 2 ];
            return out;
        }

        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        // Blend Vec3 between two frames
        const t   = ( act.time - trk.times[ai] ) / ( trk.times[ai] + trk.times[bi] );
        const ti  = 1 - t;
        const aii = ai * 3;
        const bii = bi * 3;

        out[ 0 ] = trk.values[ aii + 0 ] * ti + trk.values[ bii + 0 ] * t;
        out[ 1 ] = trk.values[ aii + 1 ] * ti + trk.values[ bii + 1 ] * t;
        out[ 2 ] = trk.values[ aii + 2 ] * ti + trk.values[ bii + 2 ] * t;
        return out;
    }

    // Get position of a joint at at a frame in animation clip
    function clipFramePosition( clip, name, fIdx ){
        const n = name + '.position';
        const t = clip.tracks.find( i=>{ return i.name === n } ); // Find Track
        const v = new Vec3();

        if( t ){
            // Calc Reverse Indexing
            if( fIdx < 0 ) fIdx = ( t.values.length / 3 ) + fIdx;

            // Get the position out of raw flat data buffer
            const i = fIdx * 3;
            v[0]    = t.values[ i + 0 ];
            v[1]    = t.values[ i + 1 ];
            v[2]    = t.values[ i + 2 ];
        }

        return v;
    }

    class RootMotion{
    // #region MAIN
        posFirst = [0,0,0];     // Position of First Frame, Used for Wrap Around Velocity Math
        posLast  = [0,0,0];     // Position of Last Frame
        posPrev  = new Vec3();  // Prev Local Position
        posCurr  = new Vec3();  // Current Local Position
        velocity = new Vec3();  // Local Velocity since last update position

        prevTime = -Infinity;   // Last action time

        action   = null;        // Animation action to monitor
        rootName = '';          // Name of joint that holds the motion
        idxTrack = -1;          // Index to the position track of bone
        idxBone  = -1;          // Index to skeleton bone of motion

        constructor( act, rName ){
            if( act && rName ) this.setAction( act, rName );
        }
    // #endregion

    // #region GETTERS/SETTERS
        setAction( act, rName ){
            this.action   = act;
            this.rootName = rName;
            this.prevTime = -Infinity;

            // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            // Find the Track Index that will contain
            // animated root positionchanges
            const key      = `${rName}.position`;
            this.idxTrack  = act._clip.tracks.findIndex( v=>(v.name === key) );

            // console.log( this.action._interpolants[3] );
            // console.log( this.action._propertyBindings[3] ); // find .binding.path = origin.position

            // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            // Cache the position of the first & last frame
            this.posFirst = clipFramePosition( act._clip, rName, 0 );
            this.posLast  = clipFramePosition( act._clip, rName, -1 );
            this.posPrev.copy( this.posFirst );

            console.log( "LAST", this.posLast[2], this.action._clip.name );
        }
    // #endregion

    // #region METHODS
        // Reset object to start fresh with the action that has been reset as well.
        reset(){
            this.prevTime = -Infinity;
            this.posPrev.copy( this.posFirst );
            this.posCurr.copy( this.posFirst );
            this.velocity.xyz( 0, 0, 0 );
            return this;
        }

        resetPos(){
            // NOTE: resultBuffer can't be trusted when there is weight on the action
            // this.posCurr.copy( this.action._interpolants[ this.idxTrack ].resultBuffer );

            actionFramePosition( this.action, this.idxTrack, this.posCurr );
            this.posPrev.copy( this.posCurr );
            this.prevTime = this.action.time;
            return this;
        }
    // #endregion

    // #region MAIN METHODS
        // Compute the current local position & velocity since last update
        update(){
            // if( Ref.i == 86 ) console.log( '~~~~~~~~~~~~~~~~~~~~~~~~~~~~~', this.action._clip.name, this.idxTrack );
            // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            const time = this.action.time;
            this.posPrev.copy( this.posCurr );      // Move to Prev
            actionFramePosition( this.action, this.idxTrack, this.posCurr );

            // this.posCurr.copy( this.action          // Get current pos created by mixer
            //     ._interpolants[ this.idxTrack ]
            //     .resultBuffer );

            // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            if( time < this.prevTime ){
                // NEW LOOP
                // wrap_around = ( curr - first ) + ( last - prev )

                // Delta between last pos in prev loop to last frame
                const delta = new Vec3();
                delta.fromSub( this.posLast, this.posPrev );

                // Delta between first pos of new loop from first frame
                this.velocity
                    .fromSub( this.posCurr, this.posFirst ) // Delta Between curr pos from first frame
                    .add( delta );                          // Add End Delta

                // if( Ref.i == 86 ){
                //     console.log( 'WRAP-deltaA', delta[2] );
                //     console.log( 'WRAP-deltaB', new Vec3().fromSub( this.posCurr, this.posFirst )[2] );
                // }
            }else{
                // CURRENT LOOP
                this.velocity.fromSub( this.posCurr, this.posPrev );
            }

            // if( Ref.i == 86 ){
            //     console.log( this.velocity );

            //     console.log( 'prev', this.posPrev[2] );
            //     console.log( 'curr', this.posCurr[2] );
            //     console.log( 'ptime', this.prevTime );
            //     console.log( 'time', time );

            //     console.log( 'First', this.posFirst[2] );
            //     console.log( 'Last', this.posLast[2] );
            // }

            // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            this.prevTime = time;   // Keep track of time to know when new starts
            return this;
        }

        // Apply velocity to object & clear motion from bone
        apply( obj, skel ){
            // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            // Make sure we have the root bone
            if( this.idxBone === -1 ){
                this.idxBone = skel.bones.findIndex( i=>(i.name === this.rootName ) );
            }

            // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            // Remove root motion - Creates in place animation
            skel.bones[ this.idxBone ].position.x = 0;
            skel.bones[ this.idxBone ].position.z = 0;

            // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            // Add velocity to 3D object
            obj.position.x += this.velocity[0];
            obj.position.z += this.velocity[2];
        }
    // #endregion
    }
// #endregion

// #region CONTROLLER
    class Controller{
    // #region MAIN
        root        = new THREE.Group();    // Container meshes
        anim        = null;                 // Animation Controller

        vel         = new FImplicitEuler( { osc:0.8 } );  // Normalized velocity
        dir         = new FImplicitEuler( { osc:2 } );    // Radian angle of rotation

        fwd         = new Vec3();   // View Forward Direction
        rit         = new Vec3();   // View Right Direction
        look        = new Vec3();   // Character Look Direction
        constructor(){}
    // #endregion

    // #region CALC
        updateCharDir( ki ){
            const ip = ki.getWASD();

            // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            // No Input, slow down to a stop
            if( ip.x === 0 && ip.y === 0 ){
                this.vel.target = 0;
                return;
            }

            // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            // Compute rotation angle & look direction from INPUT
            const fwd = new Vec3().fromScale( this.fwd, ip.y );
            const rit = new Vec3().fromScale( this.rit, ip.x );
            this.look.fromAdd( fwd, rit ).norm();

            // Compute angle of the look direction from world forward
            let rad = Vec3.angle( [0,0,1], this.look );
            if( Vec3.dot( [1,0,0], this.look ) < 0 ) rad = -rad;

            // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            // Fix angle to ignore boundary for smooth shortest path rotation
            this.dir.target = Radian.continuousTarget( this.dir.value, rad );
            this.vel.target = ki.isDown( 'shift' )? 2 : 1;
        }

        updateViewAxis( camera ){
            // Compute the XZ plane direction in relation to camera view
            const q = new Quat().copyObj( camera.quaternion );
            this.fwd.fromQuat( q, [0,0,1] ).negate().sy(0).norm();
            this.rit.fromCross( this.fwd, [0,1,0] ).norm();

            // Debug.ln.add( [0,0,0], this.fwd, 0x00ffff );
            // Debug.ln.add( [0,0,0], this.rit, 0xffff00 );
        }
    // #endregion

    // #region RENDER LOOP
        update( dt, camera, ki ){
            // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            // Updates
            this.updateViewAxis( camera );  // Compute View Directions
            this.updateCharDir( ki );       // Look direction for rotation & translation

            this.dir.update( dt );          // Run Float Spring
            this.vel.update( dt );

            // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            // Make model face same direction as camera
            const rot = new Quat().fromAxisAngle( [0,1,0], this.dir.value );
            this.root.quaternion.fromArray( rot );

            // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            //  Character animations
            this.anim.update( dt );
            this.anim.blend = this.vel.value;

            // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            // Move character toward the direction it is looking
            if( ! this.vel.isDone || this.vel.target > 0 ){
                const move = new Vec3( this.anim.velocity ).zero( 1 ); // XZ Plane
                const dist = move.len;

                // if( dist > 0.00001 ){
                    move.fromScale( this.look, dist );
                    this.root.position.x += move[0];
                    this.root.position.z += move[2];
                // }
            }
        }
    // #endregion
    }
// #endregion

</script>
<div style="position:absolute; display:fixed; top:10px; right:20px; font-size:14px; color:white; font-family:monospace;">
    WASD - Move Character ::: Hold Shift - Run!!!
</div>
</body></html>
