<!DOCTYPE html><html lang="en"><head><title></title></head>
<style>canvas{ display:block; } body, html { padding:0px; margin:0px; width:100%; height:100%; }</style>
<body><script src="../../../import-map.js"></script><script type="module">
// #region IMPORTS
import useThreeWebGL2, { THREE, useDarkScene, useVisualDebug } from '@lib/useThreeWebGL2.js';
import { GLTFLoader } from 'three/GLTFLoader.js';
import * as util      from '@lib/util.js';

import Vec3           from '@lib/maths/Vec3.js';
import Quat           from '@lib/maths/Quat.js';

import { Pane }       from '@tp/tweakpane/tweakpane-4.0.4.min.js';
// #endregion

// #region MAIN
let App   = useDarkScene( useThreeWebGL2() );
let Debug = {};
let Ref   = { blend: 0 };

window.addEventListener( 'load', async ()=>{
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	App.sphericalLook( 45, 20, 4, [0,1.0,0] );
    Debug = await useVisualDebug( App );

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    const url   = '../../../res/models/mewtwo/';
    const [ aryAnim
        , [ root0, skinned0 ]
        , [ root1, skinned1 ]
    ] = await Promise.all([
        loadAnimations( `${url}/anim_land_traverse.gltf` ),
        loadCharacter( { url: `${url}/mewtwo.gltf`, phong:0xffffff } ),
        loadCharacter( { url: `${url}/mewtwo.gltf`, phong:0xffffff } ),
    ]);

    const cWalk = aryAnim.find( i=>(i.name==='walk_loop') );
    const cRun  = aryAnim.find( i=>(i.name==='run_loop') );

    console.log( cWalk.duration, cRun.duration );

    // Add character to scene
    App.scene.add( root0 );
    App.scene.add( root1 );

    root0.position.x = -0;
    root1.position.x =  0;

    Ref.stack = [
        animate( skinned0, cWalk ),
        animate( skinned1, cRun ),
    ];

    Ref.stack[1].mixer.setTime( 0.53 );

    syncActions( Ref.stack[0].action, Ref.stack[1].action, 0.0 );
    // syncActions2( Ref.stack[0].action, Ref.stack[1].action, 0.0 );

    // Ref.skel = skinned.skeleton;
    // Ref.root = root;

    // Execute Animation
    // const clip = aryAnim[19];
    // Ref.mixer  = new THREE.AnimationMixer( skinned ); // new AnimationMixer( new Object3D() )
    // Ref.action = Ref.mixer.clipAction( clip ); // clipAction( clip, root );
    // Ref.action.play();

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    App.createRenderLoop( onPreRender ).start();
    // App.renderLoop();

    appendGithubLink( false );
    buildUI();
});


function onPreRender( dt, et ){
    if( Ref.stack ){
        for( const i of Ref.stack ){
            // i.mixer.update( 0 );

            i.mixer.update( dt );
            i.skel.bones[1].position.z = 0;
            i.skel.bones[1].position.x = 0;
        }
    }

    // if( Ref.mixer ){
    //     Ref.mixer.update( dt );
    //     Ref.rm.update().apply( Ref.root, Ref.skel );
    // }

    // if( Ref.blendSpace ){
    //     Ref.blendSpace.update( dt );
    // }
}

async function buildUI(){
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    const p = new Pane( {  } );
    p.on( 'change', e=>{
        syncActions( Ref.stack[0].action, Ref.stack[1].action, e.value );
        // syncActions2( Ref.stack[0].action, Ref.stack[1].action, e.value );
    });

    const f = p.addFolder({ title: 'Blend', expanded: true });
    // f.addButton({ title: 'Button1' }).on( 'click', ()=>console.log('Button1') );
    f.addBinding( Ref, 'blend', { min: 0.0, max: 1, step: 0.01, label: 'Blend' } );

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    Ref.pane = p;
}
// #endregion

// #region LOADING

async function loadCharacter( props={} ){
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // LOAD
    const opt = { skel:true, skelHelper:false, phong:undefined, toon:false, tpose:false, ...props };
    const tf  = await new GLTFLoader().loadAsync( opt.url );
    // const o  = firstFind( tf.scene, o=> (o.type === 'SkinnedMesh') );

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Find Skeleton & Push Skinned Meshes to the scene
    // let skel;
    let skinned;
    let mat = null;
    for( const m of util.traverseFind( tf.scene, o=> (o.type === 'SkinnedMesh') ) ){
        if( opt.phong != null ) mat = new THREE.MeshPhongMaterial( { color: opt.phong } );
        if( opt.toon ) mat = new THREE.MeshToonMaterial( { map: m.material.map, normalMap: m.material.normalMap } );

        if( mat )       m.material = mat;
        // if( !skel )     skel = m.skeleton;  // First skeleton
        if( !skinned )  skinned = m;  // First skeleton
    }

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    if( opt.tpose ){
        const clip = tf.animations.find( i=>i.name.toLowerCase() === 'tpose' );
        if( clip )  util.poseFromClip( clip, skel );
        else        console.log( 'TPose animation clip not found' );
    }

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Push Skeleton Helper
    // App.scene.add( skel.bones[0] );
    if( opt.skelHelper ){
        App.scene.add( new THREE.SkeletonHelper( skel.bones[0] ) );
    }

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    return [ tf.scene, skinned ];
}

async function loadAnimations( url ){
    const tf  = await new GLTFLoader().loadAsync( url );
    return tf.animations ?? [];
}

// #endregion

function animate( skin, clip ){
    const mixer  = new THREE.AnimationMixer( skin );
    const action = mixer.clipAction( clip );
    action.play();
    return  { mixer, action, skel: skin.skeleton };
}

function syncActions( a, b, t=0.5 ){
    const dur   = a._clip.duration * ( 1.0 - t ) +
                  b._clip.duration * t;

    const aScl  = a._clip.duration / dur;
    const bScl  = b._clip.duration / dur;

    // console.log( 'A', aScl, ( 1 / aScl )* a._clip.duration , 'B', bScl, (1 / bScl) * b._clip.duration )

    a.setEffectiveTimeScale( aScl );
    b.setEffectiveTimeScale( bScl );
}

function syncActions2( a, b, t=0.5 ){
    // const dur   = a._clip.duration * ( 1.0 - t ) +
    //               b._clip.duration * t;

    // const aScl  = a._clip.duration / dur;
    // const bScl  = b._clip.duration / dur;

    let ar = b._clip.duration / a._clip.duration; // Scale Watch to Match Run
    let br = a._clip.duration / b._clip.duration; // Scale Run to Match Walk

    // Run slowed to match walk
    // a.setEffectiveTimeScale( 1.0 );
    // b.setEffectiveTimeScale( ar );

    // Walk speed up to match run
    // a.setEffectiveTimeScale( br );
    // b.setEffectiveTimeScale( 1.0 );

    // console.log( 'A', aScl, ( 1 / aScl )* a._clip.duration , 'B', bScl, (1 / bScl) * b._clip.duration )
    // 0: Walk, 1; Run
    const ti = 1 - t;
    const aa = ti + br * t; // 0 = 1,  1 = br
    const bb = ar * ti + t; // 0 = ar, 1 = 1;

    a.setEffectiveTimeScale( aa );
    b.setEffectiveTimeScale( bb );
}

</script></body></html>
