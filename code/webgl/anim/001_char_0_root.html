<!DOCTYPE html><html lang="en"><head><title></title></head>
<style>canvas{ display:block; } body, html { padding:0px; margin:0px; width:100%; height:100%; }</style>
<body><script src="../../../import-map.js"></script><script type="module">
// #region IMPORTS
import useThreeWebGL2, { THREE, useDarkScene, useVisualDebug } from '@lib/useThreeWebGL2.js';
import { GLTFLoader } from 'three/GLTFLoader.js';
import * as util      from '@lib/util.js';

import Vec3         from '@lib/maths/Vec3.js';
import Quat         from '@lib/maths/Quat.js';
// #endregion

// #region MAIN
let App   = useDarkScene( useThreeWebGL2() );
let Debug = {};
let Ref   = {};

/*
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
https://x.com/realmattbcool/status/1978812034809524277
- https://github.com/pmndrs/viverse
- https://pmndrs.github.io/viverse/without-react/introduction#step-5:-adding-physics-and-the-character

https://discussions.unity.com/t/issue-in-state-machine-because-of-charactercontroller-isgrounded/883454

https://www.youtube.com/watch?v=EkPfhzIbp2g
https://github.com/simondevyoutube/ThreeJS_Tutorial_CharacterController/blob/main/main.js
https://github.com/simondevyoutube/ThreeJS_Tutorial_ThirdPersonCamera/blob/main/main.js

https://threejs.org/examples/?q=animation#webgl_animation_skinning_blending
https://github.com/mrdoob/three.js/blob/master/examples/webgl_animation_skinning_blending.html
https://threejs.org/examples/?q=animation#webgl_animation_skinning_additive_blending
https://github.com/mrdoob/three.js/blob/master/examples/webgl_animation_skinning_additive_blending.html



https://godotengine.org/asset-library/asset/3934
- https://github.com/Jeh3no/Godot-State-Machine-Third-Person-Controller/tree/main

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Animation Tree
https://docs.godotengine.org/en/latest/tutorials/animation/animation_tree.html
https://www.youtube.com/watch?v=iElHZhOxGYA
https://www.youtube.com/watch?v=km4SGFzpEc0
https://godotforums.org/d/33975-programmatically-setup-animation-trees/2
https://kidscancode.org/godot_recipes/4.x/animation/using_animation_sm/index.html

https://github.com/godotengine/godot/blob/540ea0b96cea2fd1b57598bdafd35b5326aac21d/scene/animation/animation_tree.h

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
https://discourse.threejs.org/t/simple-character-controller-with-animations/53542/3


https://kidscancode.org/godot_recipes/3.x/animation/animation_state_machine/index.html

https://dev.to/hnrq/using-xstate-to-coordinate-threejs-character-animations-p5k




https://github.com/MinaPecheux/godot-tutorials


 activeAction.current.setEffectiveWeight(1);
activeAction.current.setEffectiveTimeScale(1);
activeAction.current.enabled = true;
activeAction.current.clampWhenFinished = true;

action.setEffectiveWeight(1);
action.setEffectiveTimeScale(1);
action.time = 0;
action.enabled = true;
action.clampWhenFinished = true;

activeAction.current.crossFadeTo(action, 1, false);
action.play();

// activeAction.current.stop();

BlendSpace1D
*/

window.addEventListener( 'load', async ()=>{
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	App.sphericalLook( 90, 20, 8, [0,1.0,0] );
    Debug = await useVisualDebug( App );

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    const url   = '../../../res/models/mewtwo/';
    const [ [ root, skinned ], aryAnim ] = await Promise.all([
        loadCharacter( { url: `${url}/mewtwo.gltf`, phong:0xffffff } ),
        loadAnimations( `${url}/anim_land_traverse.gltf` ),
    ]);

    // aryAnim.forEach( (o,i)=>console.log( i, o.name ) );

    // Add character to scene
    App.scene.add( root );
    Ref.skel = skinned.skeleton;
    Ref.root = root;

    // Execute Animation
    const clip = aryAnim[19];
    Ref.mixer  = new THREE.AnimationMixer( skinned );
    Ref.action = Ref.mixer.clipAction( clip );
    Ref.action.play();

    await TEST();

    Ref.frame0 = clipFramePosition( clip, 'origin', 0 );
    Ref.frameX = clipFramePosition( clip, 'origin', -1 );

    // console.log( Ref.frame0, Ref.frameX );

    // skinned.skeleton.bones.forEach( (v,i)=>console.log( i, v.name ) );
    // aryAnim.forEach( (v,i)=>console.log( i, v.name ) );

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    App.createRenderLoop( onPreRender ).start();
    // App.renderLoop();
    appendGithubLink( false );
});

const PREV      = new Vec3();
const CURR      = new Vec3();
const DELTA     = new Vec3();
const DELTA2    = new Vec3();
let  LAST_TIME  = -Infinity;
function onPreRender( dt, et ){
    if( Ref.mixer ){
        Ref.mixer2.update( dt );
        Ref.mixer.update( dt );

        const t     = Ref.action.time;
        const rBone = Ref.skel.bones[1];

        if( t < LAST_TIME ){
            // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            // NEW LOOP, RESET PREV

            // Delta between last pos in prev loop to last frame
            DELTA.fromSub( Ref.frameX, PREV );
            DELTA[1] = 0;

            // Copy current postion as new PREV for next frame
            PREV.copyObj( rBone.position );
            PREV[1] = 0;

            // Delta between first pos of new loop from first frame
            DELTA2.fromSub( PREV, Ref.frame0 )
            DELTA2[1] = 0;

            // Add Both deltas !!!!
            DELTA2.add( DELTA );

            Ref.root.position.x += DELTA2[0];
            Ref.root.position.z += DELTA2[2];
        }else{
            // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            // CURRENT LOOP

            // Compute position delta
            CURR.copyObj( rBone.position );
            CURR[1] = 0;

            DELTA.fromSub( CURR, PREV );
            PREV.copy( CURR );

            // Remove Root motion - In Place Animation
            Ref.skel.bones[1].position.x = 0;
            Ref.skel.bones[1].position.z = 0;

            // Add Velocity to GLTF root
            Ref.root.position.x += DELTA[0];
            Ref.root.position.z += DELTA[2];
        }

        LAST_TIME = t;
    }
}
// #endregion

// #region LOADING

async function loadCharacter( props={} ){
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // LOAD
    const opt = { skel:true, skelHelper:false, phong:undefined, toon:false, tpose:false, ...props };
    const tf  = await new GLTFLoader().loadAsync( opt.url );
    // const o  = firstFind( tf.scene, o=> (o.type === 'SkinnedMesh') );

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Find Skeleton & Push Skinned Meshes to the scene
    // let skel;
    let skinned;
    let mat = null;
    for( const m of util.traverseFind( tf.scene, o=> (o.type === 'SkinnedMesh') ) ){
        if( opt.phong != null ) mat = new THREE.MeshPhongMaterial( { color: opt.phong } );
        if( opt.toon ) mat = new THREE.MeshToonMaterial( { map: m.material.map, normalMap: m.material.normalMap } );

        if( mat )       m.material = mat;
        // if( !skel )     skel = m.skeleton;  // First skeleton
        if( !skinned )  skinned = m;  // First skeleton
    }

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    if( opt.tpose ){
        const clip = tf.animations.find( i=>i.name.toLowerCase() === 'tpose' );
        if( clip )  util.poseFromClip( clip, skel );
        else        console.log( 'TPose animation clip not found' );
    }

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Push Skeleton Helper
    // App.scene.add( skel.bones[0] );
    if( opt.skelHelper ){
        App.scene.add( new THREE.SkeletonHelper( skel.bones[0] ) );
    }

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    return [ tf.scene, skinned ];
}

async function loadAnimations( url ){
    const tf  = await new GLTFLoader().loadAsync( url );
    return tf.animations ?? [];
}

// #endregion


function clipFramePosition( clip, name, fIdx ){
    const n = name + '.position';
    const t = clip.tracks.find( i=>{ return i.name === n } );
    const v = new Vec3();

    console.log( t );

    if( t ){
        if( fIdx < 0 ) fIdx = ( t.values.length / 3 ) + fIdx;

        const i = fIdx * 3;
        v[0] = t.values[ i + 0 ];
        v[1] = t.values[ i + 1 ];
        v[2] = t.values[ i + 2 ];
    }

    return v;
}

async function TEST(){
    const url   = '../../../res/models/mewtwo/';
    const [ [ root, skinned ], aryAnim ] = await Promise.all([
        loadCharacter( { url: `${url}/mewtwo.gltf`, phong:0xffffff } ),
        loadAnimations( `${url}/anim_land_traverse.gltf` ),
    ]);


    root.position.x = -3;

    App.scene.add( root );

    // Execute Animation
    const clip = aryAnim[19];
    Ref.mixer2  = new THREE.AnimationMixer( skinned );
    Ref.action2 = Ref.mixer2.clipAction( clip );
    Ref.action2.play();
}
</script></body></html>
