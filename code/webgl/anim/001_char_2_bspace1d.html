<!DOCTYPE html><html lang="en"><head><title></title></head>
<style>canvas{ display:block; } body, html { padding:0px; margin:0px; width:100%; height:100%; }</style>
<body><script src="../../../import-map.js"></script><script type="module">
// #region IMPORTS
import useThreeWebGL2, { THREE, useDarkScene, useVisualDebug } from '@lib/useThreeWebGL2.js';
import { GLTFLoader } from 'three/GLTFLoader.js';
import * as util    from '@lib/util.js';

import Vec3         from '@lib/maths/Vec3.js';
import Quat         from '@lib/maths/Quat.js';

import { Pane }     from '@tp/tweakpane/tweakpane-4.0.4.min.js';
// #endregion

// #region MAIN
let App   = useDarkScene( useThreeWebGL2() );
let Debug = {};
let Ref   = {};

window.addEventListener( 'load', async ()=>{
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	App.sphericalLook( 90, 20, 5, [0,1.0,0] );
    Debug = await useVisualDebug( App );

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    const url   = '../../../res/models/mewtwo/';
    const [ [ root, skinned ], aryAnim ] = await Promise.all([
        loadCharacter( { url: `${url}/mewtwo.gltf`, phong:0xffffff } ),
        loadAnimations( `${url}/anim_land_traverse.gltf` ),
    ]);

    const cIdle = aryAnim.find( i=>(i.name==='defaultidle01') ); //defaultwait_loop
    const cWalk = aryAnim.find( i=>(i.name==='walk_loop') );
    const cRun  = aryAnim.find( i=>(i.name==='run_loop') );

    // Add character to scene
    App.scene.add( root );
    Ref.skel = skinned.skeleton;
    Ref.root = root;

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    Ref.blendSpace = new BlendSpace1D( Ref.skel, 'origin' );
    Ref.blendSpace
        .addClip( cIdle )
        .addClip( cWalk )
        .addClip( cRun, 0.53 ); // Offset to make the left foot match, needed for good blending

    Ref.blendSpace.blend = 0;

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    App.createRenderLoop( onPreRender ).start();
    // App.renderLoop();

    appendGithubLink( false );
    buildUI();
});


function onPreRender( dt, et ){
    if( Ref.blendSpace ) Ref.blendSpace.update( dt );
}

async function buildUI(){
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    const DATA  = { blend : 0 };

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    const p = new Pane( {} );
    p.on( 'change', e=>{ Ref.blendSpace.blend = e.value });

    const f = p.addFolder({ title: '1D BlendSpace', expanded: true });
    f.addBinding( DATA, 'blend', { min: 0.0, max: 2, step: 0.01, label: 'Blend' } );

    const f2 = p.addFolder({ title: 'Debug', expanded: false });
    f2.addButton({ title: '0.5' }).on( 'click', ()=>{ DATA.blend = 0.5; f.refresh(); } );
    f2.addButton({ title: '1.2' }).on( 'click', ()=>{ DATA.blend = 1.2; f.refresh(); } );
    f2.addButton({ title: '1.5' }).on( 'click', ()=>{ DATA.blend = 1.5; f.refresh(); } );
    f2.addButton({ title: '1.7' }).on( 'click', ()=>{ DATA.blend = 1.7; f.refresh(); } );
    f2.addButton({ title: '2.0' }).on( 'click', ()=>{ DATA.blend = 2.0; f.refresh(); } );

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    Ref.pane = p;
}
// #endregion

// #region LOADING
    async function loadCharacter( props={} ){
        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        // LOAD
        const opt = { skel:true, skelHelper:false, phong:undefined, toon:false, tpose:false, ...props };
        const tf  = await new GLTFLoader().loadAsync( opt.url );
        // const o  = firstFind( tf.scene, o=> (o.type === 'SkinnedMesh') );

        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        // Find Skeleton & Push Skinned Meshes to the scene
        // let skel;
        let skinned;
        let mat = null;
        for( const m of util.traverseFind( tf.scene, o=> (o.type === 'SkinnedMesh') ) ){
            if( opt.phong != null ) mat = new THREE.MeshPhongMaterial( { color: opt.phong } );
            if( opt.toon ) mat = new THREE.MeshToonMaterial( { map: m.material.map, normalMap: m.material.normalMap } );

            if( mat )       m.material = mat;
            // if( !skel )     skel = m.skeleton;  // First skeleton
            if( !skinned )  skinned = m;  // First skeleton
        }

        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        if( opt.tpose ){
            const clip = tf.animations.find( i=>i.name.toLowerCase() === 'tpose' );
            if( clip )  util.poseFromClip( clip, skel );
            else        console.log( 'TPose animation clip not found' );
        }

        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        // Push Skeleton Helper
        // App.scene.add( skel.bones[0] );
        if( opt.skelHelper ){
            App.scene.add( new THREE.SkeletonHelper( skel.bones[0] ) );
        }

        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        return [ tf.scene, skinned ];
    }

    async function loadAnimations( url ){
        const tf = await new GLTFLoader().loadAsync( url );
        return tf.animations ?? [];
    }
// #endregion


// #region BLEND SPACE 1D
class BlendSpaceItem{
    constructor( act, tOff ){
        this.action      = act;
        this.timeOffset  = tOff;
    }
}

class BlendSpace1D{
    mixer       = new THREE.AnimationMixer( new THREE.Object3D() );
    rootName    = '';
    skel        = null;
    stack       = new Array();
    #blend      = 0;

    constructor( skel, rName ){
        this.skel     = skel;
        this.rootName = rName;
    }

    addClip( clip, timeOffset=0, root=null ){
        const act = this.mixer.clipAction( clip, root || this.skel.bones[0] );

        act.enabled = false;
        this.stack.push( new BlendSpaceItem( act, timeOffset ) );

        return this;
    }

    // #region GETTERS / SETTERS
    set blend( v ){
        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        // Compute Weights between two actions
        const max   = this.stack.length - 1;
        let bi      = 0;                // Index to 2nd Action
        let ai      = Math.floor( v );  // Index to 1st Action
        let bt      = v - ai;           // Weight for 2nd Action
        let at      = 0;                // Weight for 1st Action

        if( ai >= max ){        // If over, default to fully weighted final action
            ai = bi = max;
            at = bt = 1;
        }else{
            bi = ai + 1;
            at = 1.0 - bt;
        }

        this.#blend = v;

        // console.log( 'Idx', ai, 'T', at, 'bIdx', bi, 'T', bt );

        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        const a = this.stack[ ai ];
        const b = this.stack[ bi ];

        // console.log( a.action._clip.name, b.action._clip.name );

        if( ai === bi ){
            // -----------------------------
            // Single action
            a.action.enabled = true;
            a.action.setEffectiveTimeScale( 1 );
            a.action.setEffectiveWeight( 1 );
            a.action.play();
        }else{
            // console.log( a.action.enabled, b.action.enabled, a.timeOffset, b.timeOffset );
            // Set time for newly activated action
            if( a.action.enabled && !b.action.enabled ){
                // -----------------------------
                // Blend B into A
                b.action.reset();
                console.log( 'B to A' );

                const time    = ( a.action.time - a.timeOffset ) % a.action._clip.duration;
                const ratio   = time / a.action._clip.duration;
                b.action.time = b.action._clip.duration  * ratio + b.timeOffset;

            }else if( !a.action.enabled && b.action.enabled ){
                // -----------------------------
                // Blend A Into B
                a.action.reset();
                console.log( 'A to B' );

                const time    = ( b.action.time - b.timeOffset ) % b.action._clip.duration;
                const ratio   = time / b.action._clip.duration;
                a.action.time = a.action._clip.duration * ratio + a.timeOffset;

            }else if( !a.action.enabled && !b.action.enabled ){
                // -----------------------------
                // No blending, start at the same time
                console.log( 'RESET BOTH' );
                a.action.reset();
                b.action.reset();
                a.action.time = a.timeOffset;
                b.action.time = b.timeOffset;
            }

            // -----------------------------
            // Compute weight sync with time scale
            const dur  = a.action._clip.duration * at +
                         b.action._clip.duration * bt;      // Get Weighted Duration
            const aScl = a.action._clip.duration / dur;     // Calc scale for each weighted action
            const bScl = b.action._clip.duration / dur;

            // Set 1st Action
            a.action.enabled = true;
            a.action.setEffectiveTimeScale( aScl );
            a.action.setEffectiveWeight( at );
            a.action.play();

            // Set 2nd Action
            b.action.enabled = true;
            b.action.setEffectiveTimeScale( bScl );
            b.action.setEffectiveWeight( bt );
            b.action.play();
        }

        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        // Disable actions
        for( const [i,e] of this.stack.entries() ){
            if( i !== ai && i !== bi ){
                e.action.enabled = false;
                // e.action.stop();
                // console.log( 'stop', e.action._clip.name );
            }
        }
    }
    // #endregion

    update( dt ){
        // this.stack[0].action.play();
        this.mixer.update( dt );

        const b = this.skel.bones[1];
        b.position.x = 0;
        b.position.z = 0;
    }
}

</script></body></html>
