<!DOCTYPE html><html lang="en"><head><title></title></head>
<style>canvas{ display:block; } body, html { padding:0px; margin:0px; width:100%; height:100%; }</style>
<body><script src="../../../import-map.js"></script><script type="module">
// #region IMPORTS
    import useThreeWebGL2, { THREE, useDarkScene, useVisualDebug } from '@lib/useThreeWebGL2.js';
    import { GLTFLoader } from 'three/GLTFLoader.js';
    import * as util    from '@lib/util.js';

    import Pose         from '@lib/anim/Pose.js';
    import Clip         from '@lib/anim/Clip.js';
    import PoseSampler  from '@lib/anim/PoseSampler.js';

    import Timeline     from '@lib/ui/Timeline.js';
// #endregion

// #region MAIN
    let App   = useDarkScene( useThreeWebGL2() );
    let Debug = {};
    let Ref   = {};

    window.addEventListener( 'load', async ()=>{
    	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    	App.sphericalLook( 45, 20, 5, [0,1.0,0] );
        Debug   = await useVisualDebug( App );
        // Ref.ki  = new KeyboardInput();

        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        // LOAD CHAR & ANIMATION
        const url   = '../../../res/models/mewtwo/';
        const [ [ charRoot, skinned ], aryAnim ] = await Promise.all([
            loadCharacter( { url: `${url}/mewtwo.gltf`, toon:false, phong:0xffffff } ),
            loadAnimations( `${url}/anim_land_traverse.gltf` ),
        ]);

        // aryAnim.forEach( i=>console.log( i.name ) );
        const skel  = skinned.skeleton;
        const pose  = new Pose( skel, ['origin','waist'] );
        // pose.debug( Debug );
        // pose.logHierarchy();
        App.scene.add( charRoot );

        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        const cAnim = aryAnim.find( i=>(i.name==='defaultidle01') ); //defaultwait_loop
        // const cAnim = aryAnim.find( i=>(i.name==='walk_loop') );
        // const cAnim = aryAnim.find( i=>(i.name==='run_loop') );
        const clip  = new Clip().fromClip3JS( cAnim, pose );
        const samp  = new PoseSampler( clip );

        samp.setMotionMask( 0,1,0 );
        // samp.timeStep( 0.5 );
        // samp.updatePose( pose );
        // pose.toSkeleton( skel );

        Ref.samp = samp;
        Ref.pose = pose;
        Ref.skel = skel;
        Ref.clip = clip;

        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        App.createRenderLoop( onPreRender ).start();
        appendGithubLink( false );
        buildUI();
    });

    function onPreRender( dt, et ){
        // Debug.reset();
        if( Ref.samp && Ref.samp.active ){
            Ref.samp.timeStep( dt );
            Ref.samp.updatePose( Ref.pose );
            Ref.pose.toSkeleton( Ref.skel );

            if( Ref.timeln ) Ref.timeln.value = Ref.samp.clock;
        }
    }

    function buildUI(){
        const tl = new Timeline();
        tl.style.position = 'fixed';
        tl.style.bottom   = '10px';
        tl.style.left     = '10px';
        tl.style.right    = '10px';

        tl.addTrack( 'Track',[
            { name: Ref.clip.name, start: 0, duration: Ref.clip.duration }
        ]);

        tl.addEventListener( 'input', e=>{
            Ref.samp.active = false;
            Ref.samp.atTime( e.detail );
            Ref.samp.updatePose( Ref.pose );
            Ref.pose.toSkeleton( Ref.skel );
        });

        document.body.appendChild( tl );
        Ref.timeln = tl;
    }
// #endregion

// #region LOADING
    async function loadCharacter( props={} ){
        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        // LOAD
        const opt = { skel:true, skelHelper:false, phong:undefined, toon:false, tpose:false, ...props };
        const tf  = await new GLTFLoader().loadAsync( opt.url );
        // const o  = firstFind( tf.scene, o=> (o.type === 'SkinnedMesh') );

        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        // Find Skeleton & Push Skinned Meshes to the scene
        // let skel;
        let skinned;
        let mat = null;
        for( const m of util.traverseFind( tf.scene, o=> (o.type === 'SkinnedMesh') ) ){
            if( opt.phong != null ) mat = new THREE.MeshPhongMaterial( { color: opt.phong } );
            if( opt.toon ) mat = new THREE.MeshToonMaterial( { map: m.material.map, normalMap: m.material.normalMap } );

            if( mat )       m.material = mat;
            // if( !skel )     skel = m.skeleton;  // First skeleton
            if( !skinned )  skinned = m;  // First skeleton
        }

        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        if( opt.tpose ){
            const clip = tf.animations.find( i=>i.name.toLowerCase() === 'tpose' );
            if( clip )  util.poseFromClip( clip, skel );
            else        console.log( 'TPose animation clip not found' );
        }

        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        // Push Skeleton Helper
        // App.scene.add( skel.bones[0] );
        if( opt.skelHelper ){
            App.scene.add( new THREE.SkeletonHelper( skel.bones[0] ) );
        }

        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        return [ tf.scene, skinned ];
    }

    async function loadAnimations( url ){
        const tf = await new GLTFLoader().loadAsync( url );
        return tf.animations ?? [];
    }
// #endregion


</script></body></html>
