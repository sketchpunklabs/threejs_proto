<!DOCTYPE html><html lang="en"><head><title></title></head>
<style>canvas{ display:block; } body, html { padding:0px; margin:0px; width:100%; height:100%; }</style>
<body><script src="../../../import-map.js"></script><script type="module">
// #region IMPORTS
import useThreeWebGL2, { THREE, useDarkScene, useVisualDebug } from '@lib/useThreeWebGL2.js';

import facedCube           	from '@lib/meshes/FacedCube.js';
// #endregion

// #region MAIN
let App   = useDarkScene( useThreeWebGL2() );
let Debug = {};
let Ref   = {
    phy     : null,
    rb      : null,
    cube    : null,
    hitPos  : [ 0.5,0.5,0.5 ],
    force   : [ 0, 0, -40 ],
};

// https://allenchou.net/game-physics-series/
// https://allenchou.net/2013/12/game-physics-motion-dynamics-fundamentals/
// https://allenchou.net/2013/12/game-physics-motion-dynamics-implementations/

// https://github.com/ariabonczek/DSAProject/tree/master/src/Physics
// https://github.com/sebis/Motion/tree/master/engine/src/rigidbody
// https://github.com/sebis/Motion/blob/master/engine/src/rigidbody/Physics.cpp

// https://matthias-research.github.io/pages/tenMinutePhysics/index.html

// basic rigid body simulator using position based dynamics
// https://www.youtube.com/watch?v=euypZDssYxE
// https://github.com/matthias-research/pages/blob/master/tenMinutePhysics/22-rigidBodies.html

// Broad phase collision detection with Sweep and Prune
// https://www.youtube.com/watch?v=MKeWXBgEGxQ
// https://github.com/matthias-research/pages/blob/master/tenMinutePhysics/23-SAP.html

// Fast Morton Bounding Volume Hierarchies for Broad phase
// https://www.youtube.com/watch?v=LAxHQZ8RjQ4
// https://github.com/matthias-research/pages/blob/master/tenMinutePhysics/24-morton.html

/* NOTES

### Symbols
- Time : t
- Timesetep : delta
- Orientation : o(t)
- Position : x(t)
- Linear Velocity : v(t)
- Angular Velocity : w(t)
  - 2D its a scalar value
  - 3D its an axis of rotation with its magnitude as the rotation angle
- 3x3 Rotation Matrix : R( n, rad ) :: n = unit axis, rad = angle in radians

- Mass : m, how hard is it to move an object
- Moment of inertia : I, angular counterpart of mass, how hard to rotate an object
  - Different rotation axis will make moment of inertia different
  - Usually defined as a 3x3 matrix called inertia tensor
- Moment of inertia with respect to an axis : ni
  - I.ni = ni^T * I * ni
  - ni^T = Transpose of the column vector ni
  - Inertia tensors of some common primitive shapes
    goto List of 3D inertia tensors at https://en.wikipedia.org/wiki/List_of_moments_of_inertia

- Force : F(t), changes velocity & depending on point of force, change angular velocity
- Torque : r(t), all force applied that can change angular velocity.
  - r(t) = cross( r(t), F(t) )
    - cross( obj.pos - force.pos, force )
  - Defined as cross product between the vector from center of mass to the force point
  - Magnitude of Torque : len( r(t) ) = (obj.pos - force.pos) * len(force) * sin( rad )
    - rad is the angle between (obj.pos - force.pos) & force vector

- Linear Momentum : P(t), how hard to change obj's linear motion
  - P(t) = m * v(t)
- Angular Momentum : L(t), how hard to change obj's angular motion
  - Defined as the product between the inertial tensor and angular velocity
  - It is a  3D vector from 3x3 matrix of the tensor & 3D vector of angular velocity
  - L(t) = I * w(t)

- Linear Impulse : deltaP, intergral force over time
  - deltaP = F(t) * delta
  - Linear impulse is also equal to change of linear momentum
  - Change in learn velocity due to impulse is product between inverse mass and linear impulse
    - deltaV = inverse( m ) * deltaP
- Angular Impulse: deltaL, integral torque oer time
  - deltaL = r(t) * delta
  - Angular impulse is equal to the change of angular momentum
  - Change of angular velocity due to impulse is the product between inverse inertial tensor
    and angular impulse. NOTE: we have to convert the angular impulse to the object’s model 
    space and then convert the change of angular velocity back to world space, since the 
    inertia tensor is computed in the object’s model space
    - deltaW = Q * inverse( I ) * tranpose( Q ) * deltaL
    - Q is obj's orientation matrix. Q is orthogonal, so inverse( Q ) === transpose( Q )

- Applying linear / angular impulse would change the velocities

### Euler Method
- Position/Orientation change over a timestep is the integration of velocity over time
  x(t + delta) = x(t) + v(t) * delta
  o(t + delta) = o(t) + w(t) * delta :: 2D

  o(t + delta) = R( norm(w(t)), len(w(t)) * delta ) * o(t) :: 3x3 matrix way

### Inertia tensors math for non common primitive shapes
[
y^2 + z^2,      -xy,           -xz
-xy             x^2 + z^2,     -yz
-xz             -yz            x^2 + y^2
] * pdV

v       = Volume of Shape
dV      = infinitesimal volume within V at [x,y,z]
p       = density of dV
[x,y,z] = coordinates relative to the reference point of choice

*/

window.addEventListener( 'load', async ()=>{
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	App.sphericalLook( 45, 20, 10 );
    Debug = await useVisualDebug( App );

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    Ref.cube = facedCube();
    App.scene.add( Ref.cube );

    Debug.pnt.add( Ref.hitPos, 0xffff00, 3 );
    Debug.ln.add( Ref.hitPos, new Vec3( Ref.hitPos ).add( Ref.force), 0xffff00 );

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // testMat3();
    Ref.phy = new PhysicsEngine()
        .setFramerate( 30 );

    Ref.rb = new RigidBody();
    InertiaTensor.solidCuboid( 1, 1, 1, 1, Ref.rb.inertialTensor );
    
    Ref.rb.linearDamping = 0.8;
    Ref.rb.setMass( 1 );
    // Ref.rb.applyForce( [0,0,-60] );
    // Ref.rb.applyImpulse( [0,0,-4] );
    // Ref.rb.applyTorque( [1,0,0] );
    // Ref.rb.applyForce( Ref.force, Ref.hitPos );

    setTimeout( ()=>Ref.rb.applyForce( Ref.force, Ref.hitPos ), 1000 );
    // Ref.rb.integrate( 1/5 );

    // const q = new Quat().fromMat3( Ref.rb.orientation ).norm();
    // Ref.cube.quaternion.fromArray( q );
    // console.log( Ref.rb, q );

    // const rb = new RigidBody();
    // rb.applyForce( [0,0,-10] );
    // rb.applyForce( [0,20,0] );

    // const prev = new Vec3();
    // for( let i=0; i < 10; i++ ){
    //     // rb.applyForce( [0,0,-10] );
    //     // rb.applyForce( [0,-9.8,0] ); // Gravity
    //     rb.integrate( 1/5 );

    //     Debug.ln.add( prev, rb.position, 0x00ff00 );
    //     Debug.pnt.add( rb.position, 0x00ff00, 3 );
    //     prev.copy( rb.position );
    // }

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    App.createRenderLoop( onPreRender ).start();
    // App.renderLoop();
});

function onPreRender( dt, et ){
    Ref.phy.update( dt, [ Ref.rb ] );
    Ref.cube.position.fromArray( Ref.rb.position );
    Ref.cube.quaternion.fromArray( Ref.rb.quat );
};

function testMat3(){
    const m3 = new Mat3();
    // m3.fromAxisAngle( [1,0,0], 45 * Math.PI / 180 );
    // m3.applyAxisAngle( [0,1,0], 90 * Math.PI / 180 );
    // m3.applyAxisAngle( [0,0,1], 45 * Math.PI / 180 );
    m3.fromLook( [1,0,0], [0,1,0] );

    const ax = m3.getAxes();
    console.log( ax );

    const org = [0,0,0];
    Debug.ln.add( org, ax.x, 0xff0000 );
    Debug.ln.add( org, ax.y, 0x00ff00 );
    Debug.ln.add( org, ax.z, 0x0000ff );
}
// #endregion

// #region IMPL

// https://en.wikipedia.org/wiki/List_of_moments_of_inertia
// Defines the distribution of mass in a rigid body relative to its axes of rotation
// Plays a role in how a body resists rotational motion & how to heaves when applied
// to rotational foraces ( torques )
class InertiaTensor{
    static solidSphere( m=1, r=1, m3=null ){
        const out = m3 || [0,0,0, 0,0,0, 0,0,0];
        const i   = ( 2 / 5 ) * m * r * r;

        out[0] = i; // I_xx
        out[1] = 0;
        out[2] = 0;
        
        out[3] = 0;
        out[4] = i; // I_yy
        out[5] = 0;

        out[6] = 0;
        out[7] = 0;
        out[8] = i; // I_zz

        return out;
    }

    static solidCuboid( m=1, w=1, h=1, d=1, m3=null ){
        const out = m3 || [0,0,0, 0,0,0, 0,0,0];

        out[0] = ( 1 / 12 ) * m * ( h * h + d * d ); // x - width
        out[1] = 0;
        out[2] = 0;
        
        out[3] = 0;
        out[4] = ( 1 / 12 ) * m * ( w * w + d * d ); // y - height
        out[5] = 0;

        out[6] = 0;
        out[7] = 0;
        out[8] = ( 1 / 12 ) * m * ( w * w + h * h ); // z - depth

        return out;
    }

    static solidCapsule( m=1, r=1, h=1, m3=null ){
        const out     = m3 || [0,0,0, 0,0,0, 0,0,0];
        const I_xx_yy = ( 1 / 12 ) * m * ( 3 * r * r + h * h ) + ( 1 / 2 ) * m * r * r;
        const I_zz    = ( 1 / 2 )  * m * r * r + (1 / 4) * m * h * h;

        out[0] = I_xx_yy;
        out[1] = 0;
        out[2] = 0;
        
        out[3] = 0;
        out[4] = I_xx_yy;
        out[5] = 0;

        out[6] = 0;
        out[7] = 0;
        out[8] = I_zz;

        return out;
    }

    // Plane faces Y UP, with width at x and height at z
    static yPlane( m=1, w=1, h=1 ){
        const out = m3 || [0,0,0, 0,0,0, 0,0,0];

        out[0] = (1 / 12) * m * h * h;
        out[1] = 0;
        out[2] = 0;
        
        out[3] = 0;
        out[4] = ( 1 / 12) * m * ( w * w + h * h );
        out[5] = 0;

        out[6] = 0;
        out[7] = 0;
        out[8] = ( 1 / 12 ) * m * w * w;

        return out;
    }
}

class Collider{
    mass                = -1;
    localInertiaTensor  = [];
    localCentroid       = [0,0,0];
}

class RigidBody{
    mass                = 1;
    inverseMass         = 1;
    // localInverseTensor  = new Mat3();
    // worldInverseTensor  = new Mat3();

    // worldCentroid       = new Vec3();
    // localCentroid       = new Vec3();

    position            = new Vec3();
    orientation         = new Mat3();
    quat                = new Quat();
    linearDamping       = 0.95;
    linearVelocity      = new Vec3();
    angularVelocity     = new Vec3();
    angularDamping      = 0.9;

    forceAccumulator    = new Vec3();
    torqueAccumulator   = new Vec3();

    consstructor(){
        console.log( this.quat );
    }
    
    // colliders           = [];
    inertialTensor = new Mat3();

    setMass( v ){
        this.mass        = v;
        this.inverseMass = 1 / v;
        return this;
    }

    UpdateGlobalCentroidFromPosition(){
        // globalCentroid = orientation * localCentroid + position
    }
    UpdatePositionFromGlobalCentroid(){
        // position = orientation * (-localCentroid) + globalCentroid
    }

    UpdateOrientation(){
        // Notes:
        // - Not using Gram-Schmidt process to re-orthonormalize the matrix 
        //   as it does not treat all axes equally

        // orthonormalize orientation matrix
        // Quat q = m_orientation.ToQuat();
        // q.Normalize();
        // m_orientation = q.ToMatrix();
        
        // // compute inverse orientation matrix
        // m_inverseOrientation = m_orientation.Transposed();
    }
 
    AddCollider( collider ){
        // // add collider to collider list
        // m_colliders.Add(collider);
        
        // // reset local centroid & mass
        // m_localCentroid.Zero();
        // m_mass = 0.0f;

        // // compute local centroid & mass
        // for (Collider &collider : m_colliders){
        //     // accumulate mass
        //     m_mass += collider.m_mass;

        //     // accumulate weighted contribution
        //     m_localCentroid += 
        //         collider.m_mass * collider.m_localCentroid;
        // }

        // // compute inverse mass
        // m_massData.inverseMass = 1.0f / m_mass;

        // // compute final local centroid
        // m_localCentroid *= m_massData.inverseMass;

        // // compute local inertia tensor
        // Mat3 localInertiaTensor;
        // localInertiaTensor.Zero();
        // for (Collider &collider : m_colliders){
        //     const Vec3 r = m_localCentroid - collider.m_localCentroid;
        //     const float rDotR = r.Dot(r);
        //     const Mat3 rOutR = r.OuterProduct(r);

        //     // accumulate local inertia tensor contribution, 
        //     // using Parallel Axis Theorem
        //     localInertiaTensor += 
        //         collider.localInertiaTensor 
        //         + collider.m_mass * (rDotR * Mat3::Identity() - rOutR);
        // }

        // // compute inverse inertia tensor
        // m_localInverseInertiaTensor = localInertiaTensor.Inverted();
    }
    
    // #region SPACE CONVERSIOON
    LocalToGlobal( p ){
        // return m_orientation * p + m_position;
    }

    GlobalToLocal( p ){
        // m_inverseOrientation * (p - m_position);
    }

    LocalToGlobalVec( v ){
        // return m_orientation * v;
    }
    GlobalToLocalVec( v ){
        // return m_inverseOrientation * v;
    }
    // #endregion
    
    // Continuous force applied over time, acceleration
    applyForce( force, hitPos=null ){
        this.forceAccumulator.add( force ); // m_forceAccumulator  += f;

        if( hitPos ){
            const v = new Vec3()
                // .fromSub( hitPos, this.position ) // Rotation seems backwards
                .fromSub( this.position, hitPos )
                .cross( force );

            Debug.pnt.add( this.position, 0x00ffff, 3 );
            
            Debug.ln.add( this.position, new Vec3(this.position).add( force ), 0xffff00 );
            Debug.ln.add( this.position, new Vec3(this.position).add( v ), 0x00ffff );

            this.torqueAccumulator.add( v );
        }

        // cross( ( hitPos - worldCentroid ), f );
        // this.torqueAccumulator.add( new Vec3( hitPos )
        //     .sub( this.globalCentroid )
        //     .cross( force )
        // ); // m_torqueAccumulator += (at - m_globalCentroid).Cross(f);

        return this;
    }
 
    applyTorque( v ){ this.torqueAccumulator.add( v ); return this; }

    // Impulse is a sudden & instant increase of velocity
    applyImpulse( force, hitPos ){
        // velocity += force * ( 1 / mass )
        this.linearVelocity.scaleThenAdd( this.inverseMass, force );

        // // calculate impulsive torque generated by the impulse with the given contact point
        // glm::vec3 impulsiveTorque = glm::cross(point - m_position, impulse);

        // // calculate the angular velocity the impulsive torque generates
        // glm::mat3 inertiaTensor = m_rotation * m_inertiaTensor * glm::transpose(m_rotation);
        // m_angularVelocity += glm::inverse(inertiaTensor) * impulsiveTorque
        return this;
    }


    integrate( dt ){
        const v = new Vec3();

        // m_acceleration = (1.0f/m_mass) * m_forceAccumulator;
        // m_velocity += m_acceleration * dt;
        // m_velocity *= glm::pow(m_damping, dt);
        // m_position += m_velocity * dt;

        // Acceleration
        this.forceAccumulator.scale( this.inverseMass );

        // Move tensor to worldspace, First rotation moves it to ws but the transpose ensures
        // that the tensor is properly aligned with world space. With how the tensor transforms
        // vectors needs this extra mul with the transpose to make it correctly transform torque 
        // vectors in that world space into angular acceleration

        // glm::mat3 inertiaTensor = m_rotation * m_inertiaTensor * glm::transpose(m_rotation);
        // m_angularAcceleration = glm::inverse(inertiaTensor) * m_torqueAccumulator;

        // const tensor = new Mat3( this.inertialTensor );
        const tensor = new Mat3( this.orientation )
            .transpose()
            .pmul( this.inertialTensor )
            .pmul( this.orientation );
        
        tensor.invert().transformVec3( this.torqueAccumulator ); // calc acceleration

        // Velocity
        this.linearVelocity
            .add( this.forceAccumulator.scale( dt ) )   // Apply Accel
            .scale( this.linearDamping**dt );           // Apply Exponential Decay Damping

        // m_angularVelocity += m_angularAcceleration * dt;
        // m_angularVelocity *= glm::pow(m_angularDamping, dt);

        this.angularVelocity
            .add( this.torqueAccumulator.scale( dt ) )  // Apply Accel
            .scale( this.angularDamping**dt );       // Apply Exponential Decay Damping


        // TODO Apply Drag force k * vel^2

        // Update Transform
        this.position.scaleThenAdd( dt, this.linearVelocity );

        // float angle = glm::length(m_angularVelocity) * dt;
        // if (angle != 0)
        // 	m_rotation = glm::mat3(glm::rotate(glm::mat4(m_rotation), glm::degrees(angle), m_angularVelocity));

        const rad = Vec3.len( this.angularVelocity ) * dt;
        if( rad !== 0 ){
            v.fromNorm( this.angularVelocity );
            this.orientation.applyAxisAngle( v, rad, true );
            this.quat.fromMat3( this.orientation ).norm();
        }

        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        // Vector3 linearAcceleration = m_ForceAccumulator * (1.0f / m_Mass);
        // m_LinearVelocity = (m_LinearVelocity + linearAcceleration) * m_LinearDamping;
        // m_Position += m_LinearVelocity;

        // velocity += inverseMass * ( forceAccumulator * dt )
        // this.linearVelocity.add(
        //     this.forceAccumulator.scale( dt ).scale( this.inverseMass )
        // );

        // position += linearVelocity * dt;
        // this.position.scaleThenAdd( dt, this.linearVelocity );

        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        // Cleanup
        this.forceAccumulator.zero();
        this.torqueAccumulator.zero();

        //     // integrate linear velocity
        //     body.m_linearVelocity += 
        //         body.m_massData.inverseMass
        //         * (body.m_forceAccumulator * dt);
            
        //     // integrate angular velocity
        //     body.m_angularVelocity += 
        //         body.m_globalInverseInertiaTensor 
        //         * (body.m_torqueAccumulator * dt);
            
        //     // zero out accumulated force and torque
        //     body.m_forceAccumulator.Zero();
        //     body.m_torqueAccumulator.Zero();
            
        //     // integrate position
        //     m_globalCentroid += m_linearVelocity * dt;
            
        //     // integrate orientation
        //     const Vec3 axis = m_angularVelocity.Normalized();
        //     const float angle = m_angularVelocity.Length() * dt;
        //     m_orientation = RotationMatrix(axis, angle) * m_orientation;
            
        //     // update physical properties
        //     body.UpdateOrientation();
        //     body.UpdatePositionFromGlobalCentroid();
    }

    // void RigidBody::integrate(float dt)
    // {
    //     assert(dt > 0.0f);

    //     // Calculate acceleration from affecting forces
    //     m_acceleration = (1.0f/m_mass) * m_forceAccumulator;

    //     // Calculate angular acceleration from affecting torques
    //     glm::mat3 inertiaTensor = m_rotation * m_inertiaTensor * glm::transpose(m_rotation);
    //     m_angularAcceleration = glm::inverse(inertiaTensor) * m_torqueAccumulator;

    //     // Update velocities
    //     m_velocity += m_acceleration * dt;
    //     m_angularVelocity += m_angularAcceleration * dt;

    //     // Calculate drag effect on velocities
    //     m_velocity *= glm::pow(m_damping, dt);
    //     m_angularVelocity *= glm::pow(m_angularDamping, dt);

    //     // Update position and orientation
    //     m_position += m_velocity * dt;

    //     float angle = glm::length(m_angularVelocity) * dt;
    //     if (angle != 0)
    //         m_rotation = glm::mat3(glm::rotate(glm::mat4(m_rotation), glm::degrees(angle), m_angularVelocity));

    //     // clear the  accumulators
    //     m_forceAccumulator = glm::vec3(0.0f);
    //     m_torqueAccumulator = glm::vec3(0.0f);
    // }
}

class PhysicsEngine{
    timeStep    = 1 / 10; // in Sec
    accumulator = 0;
    frameCnt    = 0;
    constructor(){}

    setFramerate( f ){ this.timeStep = 1 / f; return this; }

    update( dt, bodies=[] ){
        // Run a step for every possible fixed time that has been accumulated
        this.accumulator += dt; // MS to S
        this.frameCnt++;

        // console.log( dt, this.timeStep  );

        const run = ( this.accumulator >= this.timeStep );

        while( this.accumulator >= this.timeStep ){
            this.step( this.timeStep, bodies );
            // console.log( 'x', this.frameCnt, this.accumulator, 'Frames', Math.round(1/dt) );
            // this.step( this.timeStep );
            this.accumulator -= this.timeStep;
        }

        if( run ) this.frameCnt = 0;
    }

    // https://github.com/sebis/Motion/blob/master/engine/src/rigidbody/Physics.cpp#L49
    // 1. Loop all rigid bodies
    // 1.1 Apply Gravity
    // 1.2 Intergrate - https://github.com/sebis/Motion/blob/master/engine/src/rigidbody/RigidBody.cpp#L54
    // 2. Detect Collisions
    // 3. Resolve collisions & write velocity to rigid body
    step( ts, bodies ){

        for( const b of bodies ){
            b.integrate( ts );
        }

        // for each rigid body
        // for (auto &body : rigidBodies){
        //     // integrate linear velocity
        //     body.m_linearVelocity += 
        //         body.m_massData.inverseMass
        //         * (body.m_forceAccumulator * dt);
            
        //     // integrate angular velocity
        //     body.m_angularVelocity += 
        //         body.m_globalInverseInertiaTensor 
        //         * (body.m_torqueAccumulator * dt);
            
        //     // zero out accumulated force and torque
        //     body.m_forceAccumulator.Zero();
        //     body.m_torqueAccumulator.Zero();
            
        //     // integrate position
        //     m_globalCentroid += m_linearVelocity * dt;
            
        //     // integrate orientation
        //     const Vec3 axis = m_angularVelocity.Normalized();
        //     const float angle = m_angularVelocity.Length() * dt;
        //     m_orientation = RotationMatrix(axis, angle) * m_orientation;
            
        //     // update physical properties
        //     body.UpdateOrientation();
        //     body.UpdatePositionFromGlobalCentroid();


                    
            /* tut says to do this somewhere, maybe here will work.
            Inverse Inertia Tensor Update - https://allenchou.net/2013/12/game-physics-motion-dynamics-implementations/
            NOTE: Where the hell is massData???
            
            m_globalInverseInertiaTensor = 
        m_orientation 
        * m_massData.localInertiaTensor 
        * m_inverseOrientation;
            */

        // }
    }
}

// #endregion

// #region MATHS

class Mat3 extends Array{
    constructor( v=null ){
        super( 9 );
        if( v?.length === 9 ) this.copy( v );
        else                  this.identity();
    }

    // #region SETTERS
    identity(){
        this[0] = 1;
        this[1] = 0;
        this[2] = 0;
        this[3] = 0;
        this[4] = 1;
        this[5] = 0;
        this[6] = 0;
        this[7] = 0;
        this[8] = 1;
        return this;
    }

    copy( v ){
        this[0] = v[0];
        this[1] = v[1];
        this[2] = v[2];
        this[3] = v[3];
        this[4] = v[4];
        this[5] = v[5];
        this[6] = v[6];
        this[7] = v[7];
        this[8] = v[8];
        return this;
    }
    // #endregion

    // #region GETTERS
    getAxes( o={ x:[0,0,0], y:[0,0,0], z:[0,0,0] } ){
        o.x[ 0 ] = this[0];
        o.x[ 1 ] = this[1];
        o.x[ 2 ] = this[2];

        o.y[ 0 ] = this[3];
        o.y[ 1 ] = this[4];
        o.y[ 2 ] = this[5];

        o.z[ 0 ] = this[6];
        o.z[ 1 ] = this[7];
        o.z[ 2 ] = this[8];
        return o;
    }

    determinant(){
        const a00 = this[0];
        const a01 = this[1];
        const a02 = this[2];
        const a10 = this[3];
        const a11 = this[4];
        const a12 = this[5];
        const a20 = this[6];
        const a21 = this[7];
        const a22 = this[8];

        return (
            a00 * ( a22 * a11 - a12 * a21) +
            a01 * (-a22 * a10 + a12 * a20) +
            a02 * ( a21 * a10 - a11 * a20)
        );
    }
    // #endregion

    // #region OPERATORS
    mul( b ){
        const a00 = this[0];
        const a01 = this[1];
        const a02 = this[2];
        const a10 = this[3];
        const a11 = this[4];
        const a12 = this[5];
        const a20 = this[6];
        const a21 = this[7];
        const a22 = this[8];

        let b0  = b[0];
        let b1  = b[1];
        let b2  = b[2];
        this[0] = b0 * a00 + b1 * a10 + b2 * a20;
        this[1] = b0 * a01 + b1 * a11 + b2 * a21;
        this[2] = b0 * a02 + b1 * a12 + b2 * a22;

        b0      = b[3];
        b1      = b[4];
        b2      = b[5];
        this[3] = b0 * a00 + b1 * a10 + b2 * a20;
        this[4] = b0 * a01 + b1 * a11 + b2 * a21;
        this[5] = b0 * a02 + b1 * a12 + b2 * a22;

        b0      = b[6];
        b1      = b[7];
        b2      = b[8];
        this[6] = b0 * a00 + b1 * a10 + b2 * a20;
        this[7] = b0 * a01 + b1 * a11 + b2 * a21;
        this[8] = b0 * a02 + b1 * a12 + b2 * a22;
        return this;
  }

    pmul( a ){
        const a00 = a[0];
        const a01 = a[1];
        const a02 = a[2];
        const a10 = a[3];
        const a11 = a[4];
        const a12 = a[5];
        const a20 = a[6];
        const a21 = a[7];
        const a22 = a[8];

        let b0  = this[0];
        let b1  = this[1];
        let b2  = this[2];
        this[0] = b0 * a00 + b1 * a10 + b2 * a20;
        this[1] = b0 * a01 + b1 * a11 + b2 * a21;
        this[2] = b0 * a02 + b1 * a12 + b2 * a22;

        b0      = this[3];
        b1      = this[4];
        b2      = this[5];
        this[3] = b0 * a00 + b1 * a10 + b2 * a20;
        this[4] = b0 * a01 + b1 * a11 + b2 * a21;
        this[5] = b0 * a02 + b1 * a12 + b2 * a22;

        b0      = this[6];
        b1      = this[7];
        b2      = this[8];
        this[6] = b0 * a00 + b1 * a10 + b2 * a20;
        this[7] = b0 * a01 + b1 * a11 + b2 * a21;
        this[8] = b0 * a02 + b1 * a12 + b2 * a22;
        return this;
    }

    translate( v ){
        const a00 = this[0];
        const a01 = this[1];
        const a02 = this[2];
        const a10 = this[3];
        const a11 = this[4];
        const a12 = this[5];
        const a20 = this[6];
        const a21 = this[7];
        const a22 = this[8];
        const x   = v[0];
        const y   = v[1];

        this[0] = a00;
        this[1] = a01;
        this[2] = a02;

        this[3] = a10;
        this[4] = a11;
        this[5] = a12;

        this[6] = x * a00 + y * a10 + a20;
        this[7] = x * a01 + y * a11 + a21;
        this[8] = x * a02 + y * a12 + a22;
        return this;
    }

    scale( v ){
        const x = v[0];
        const y = v[1];

        this[0] = x * a[0];
        this[1] = x * a[1];
        this[2] = x * a[2];

        this[3] = y * a[3];
        this[4] = y * a[4];
        this[5] = y * a[5];

        this[6] = a[6];
        this[7] = a[7];
        this[8] = a[8];
        return this;
    }
    
    invert(){
        const a00 = this[0];
        const a01 = this[1];
        const a02 = this[2];
        const a10 = this[3];
        const a11 = this[4];
        const a12 = this[5];
        const a20 = this[6];
        const a21 = this[7];
        const a22 = this[8];

        const b01 = a22 * a11 - a12 * a21;
        const b11 = -a22 * a10 + a12 * a20;
        const b21 = a21 * a10 - a11 * a20;

        // Calculate the determinant
        let det = a00 * b01 + a01 * b11 + a02 * b21;
        if( !det ){ console.log( 'Mat3 can not invert because of determinate' ); return this; }

        det     = 1.0 / det;
        this[0] = b01 * det;
        this[1] = (-a22 * a01 + a02 * a21) * det;
        this[2] = (a12 * a01 - a02 * a11) * det;
        this[3] = b11 * det;
        this[4] = (a22 * a00 - a02 * a20) * det;
        this[5] = (-a12 * a00 + a02 * a10) * det;
        this[6] = b21 * det;
        this[7] = (-a21 * a00 + a01 * a20) * det;
        this[8] = (a11 * a00 - a01 * a10) * det;
        return this;
    }

    transpose(){
        const a01 = this[1];
        const a02 = this[2];
        const a12 = this[5];
        this[1]   = this[3];
        this[2]   = this[6];
        this[3]   = a01;
        this[5]   = this[7];
        this[6]   = a02;
        this[7]   = a12;
        return this;
    }

    transformVec3( a, o=null ){
        const x     = a[0];
        const y     = a[1];
        const z     = a[2];

        const out   = o || a;
        out[0]      = x * this[0] + y * this[3] + z * this[6];
        out[1]      = x * this[1] + y * this[4] + z * this[7];
        out[2]      = x * this[2] + y * this[5] + z * this[8];
        return out;
    }
    
    // pmul's axis angle rotation onto matrix
    applyAxisAngle( axis, rad, doPMUL=true ){
        // Compute sine and cosine of the angle
        const s = Math.sin( rad );
        const c = Math.cos( rad) ;
        const t = 1 - c;

        // Construct the rotation matrix using Rodrigues' formula
        const x = axis[0];
        const y = axis[1];
        const z = axis[2];
        const r = [
            t * x * x + c,      t * x * y - s * z,  t * x * z + s * y,  // First row
            t * x * y + s * z,  t * y * y + c,      t * y * z - s * x,  // Second row
            t * x * z - s * y,  t * y * z + s * x,  t * z * z + c       // Third row
        ];

        ( doPMUL )
            ? this.fromMul( r, this ) 
            : this.fromMul( this, r ); 

        return this;
    }
    
    orthoNorm(){
        // Not using Gram-Schmidt process to orthonormalize the matrix 
        // as it does not treat all axes equally, so quaternions it is.
        this.fromQuat( new Quat().fromMat3( this ).norm() );
    }
    // #endregion

    // #region FROM 
    fromMul( a, b ){
        const a00 = a[0];
        const a01 = a[1];
        const a02 = a[2];
        const a10 = a[3];
        const a11 = a[4];
        const a12 = a[5];
        const a20 = a[6];
        const a21 = a[7];
        const a22 = a[8];

        let b0 = b[0];
        let b1 = b[1];
        let b2 = b[2];
        this[0] = b0 * a00 + b1 * a10 + b2 * a20;
        this[1] = b0 * a01 + b1 * a11 + b2 * a21;
        this[2] = b0 * a02 + b1 * a12 + b2 * a22;

        b0 = b[3];
        b1 = b[4];
        b2 = b[5];
        this[3] = b0 * a00 + b1 * a10 + b2 * a20;
        this[4] = b0 * a01 + b1 * a11 + b2 * a21;
        this[5] = b0 * a02 + b1 * a12 + b2 * a22;

        b0 = b[6];
        b1 = b[7];
        b2 = b[8];
        this[6] = b0 * a00 + b1 * a10 + b2 * a20;
        this[7] = b0 * a01 + b1 * a11 + b2 * a21;
        this[8] = b0 * a02 + b1 * a12 + b2 * a22;
        return this;
  }

    fromAdjoint( a ){
        const a00 = a[0];
        const a01 = a[1];
        const a02 = a[2];
        const a10 = a[3];
        const a11 = a[4];
        const a12 = a[5];
        const a20 = a[6];
        const a21 = a[7];
        const a22 = a[8];

        this[0] = a11 * a22 - a12 * a21;
        this[1] = a02 * a21 - a01 * a22;
        this[2] = a01 * a12 - a02 * a11;
        this[3] = a12 * a20 - a10 * a22;
        this[4] = a00 * a22 - a02 * a20;
        this[5] = a02 * a10 - a00 * a12;
        this[6] = a10 * a21 - a11 * a20;
        this[7] = a01 * a20 - a00 * a21;
        this[8] = a00 * a11 - a01 * a10;
        return this;
    }

    fromInvert( a ){
        const a00 = a[0],
              a01 = a[1],
              a02 = a[2];
        const a10 = a[3],
              a11 = a[4],
              a12 = a[5];
        const a20 = a[6],
              a21 = a[7],
              a22 = a[8];

        const b01 = a22 * a11 - a12 * a21;
        const b11 = -a22 * a10 + a12 * a20;
        const b21 = a21 * a10 - a11 * a20;

        // Calculate the determinant
        let det = a00 * b01 + a01 * b11 + a02 * b21;
        if( !det ){ console.log( 'Mat3 can not invert because of determinate' ); return this; }

        det     = 1.0 / det;
        this[0] = b01 * det;
        this[1] = (-a22 * a01 + a02 * a21) * det;
        this[2] = (a12 * a01 - a02 * a11) * det;
        this[3] = b11 * det;
        this[4] = (a22 * a00 - a02 * a20) * det;
        this[5] = (-a12 * a00 + a02 * a10) * det;
        this[6] = b21 * det;
        this[7] = (-a21 * a00 + a01 * a20) * det;
        this[8] = (a11 * a00 - a01 * a10) * det;
        return this;
    }

    fromTranspose( a ){
        // If we are transposing ourselves we can skip a few steps but have to cache some values
        if( this === a ){
            const a01 = a[1],
                  a02 = a[2],
                  a12 = a[5];
            
            out[1] = a[3];
            out[2] = a[6];
            out[3] = a01;
            out[5] = a[7];
            out[6] = a02;
            out[7] = a12;
        }else{
            out[0] = a[0];
            out[1] = a[3];
            out[2] = a[6];
            out[3] = a[1];
            out[4] = a[4];
            out[5] = a[7];
            out[6] = a[2];
            out[7] = a[5];
            out[8] = a[8];
        }
        return this;
    }

    fromAxisAngle( axis, rad ){
        // Normalize the axis vector
        const len = Math.sqrt( axis[0]**2 + axis[1]**2 + axis[2]**2 );
        const x   = axis[0] / len;
        const y   = axis[1] / len;
        const z   = axis[2] / len;

        // Compute sine and cosine of the angle
        const s = Math.sin( rad );
        const c = Math.cos( rad );
        const t = 1 - c;

        // Construct the rotation matrix using Rodrigues' formula
        this[0] = t * x * x + c;      // m00
        this[1] = t * x * y - s * z;  // m01
        this[2] = t * x * z + s * y;  // m02

        this[3] = t * x * y + s * z;  // m10
        this[4] = t * y * y + c;      // m11
        this[5] = t * y * z - s * x;  // m12

        this[6] = t * x * z - s * y;  // m20
        this[7] = t * y * z + s * x;  // m21
        this[8] = t * z * z + c;      // m22

        return this;
    }

    fromLook( fwd, up=[0,1,0] ){
        // Compute the right vector (X-axis) as the cross product of up and forward
        // And normalize it
        const rit = [
            up[1] * fwd[2] - up[2] * fwd[1],
            up[2] * fwd[0] - up[0] * fwd[2],
            up[0] * fwd[1] - up[1] * fwd[0] 
        ];

        let len = Math.sqrt( rit[0]**2 + rit[1]**2 + rit[2]**2 );
        rit[0] /= len;
        rit[1] /= len;
        rit[2] /= len;
        
        // Recompute the up unit vector (Y-axis) to ensure all vectors are orthogonal
        this[3]  = fwd[1] * rit[2] - fwd[2] * rit[1]; // m10
        this[4]  = fwd[2] * rit[0] - fwd[0] * rit[2]; // m11
        this[5]  = fwd[0] * rit[1] - fwd[1] * rit[0]; // m12

        len      = Math.sqrt( this[3]**2 + this[4]**2 + this[5]**2 );
        this[3] /= len;
        this[4] /= len;
        this[5] /= len;

        // Fill the mat3 with the orthogonal vectors
        this[0] = rit[0];  // m00
        this[1] = rit[1];  // m01
        this[2] = rit[2];  // m02

        this[6] = fwd[0];  // m20
        this[7] = fwd[1];  // m21
        this[8] = fwd[2];  // m22

        return this;
    }
    // #endregion

    // #region FROM CONVERT
    fromOuterProduct( a, b ){
        this[0] = a[0] * b[0];  // m00
        this[1] = a[0] * b[1];  // m01
        this[2] = a[0] * b[2];  // m02

        this[3] = a[1] * b[0];  // m10
        this[4] = a[1] * b[1];  // m11
        this[5] = a[1] * b[2];  // m12

        this[6] = a[2] * b[0];  // m20
        this[7] = a[2] * b[1];  // m21
        this[8] = a[2] * b[2];  // m22

        return out;
    }

    fromQuat( q ){
        const x  = q[0];
        const y  = q[1];
        const z  = q[2];
        const w  = q[3];
        const x2 = x + x;
        const y2 = y + y;
        const z2 = z + z;

        const xx = x * x2;
        const yx = y * x2;
        const yy = y * y2;
        const zx = z * x2;
        const zy = z * y2;
        const zz = z * z2;
        const wx = w * x2;
        const wy = w * y2;
        const wz = w * z2;

        this[0] = 1 - yy - zz;
        this[3] = yx - wz;
        this[6] = zx + wy;

        this[1] = yx + wz;
        this[4] = 1 - xx - zz;
        this[7] = zy - wx;

        this[2] = zx - wy;
        this[5] = zy + wx;
        this[8] = 1 - xx - yy;

        return this;
    }

    fromMat4( a ){
        this[0] = a[0];
        this[1] = a[1];
        this[2] = a[2];
        this[3] = a[4];
        this[4] = a[5];
        this[5] = a[6];
        this[6] = a[8];
        this[7] = a[9];
        this[8] = a[10];
        return this;
    }
    
    // Calculates a mat3 normal matrix (adjoint) from the upper 3x3 of a Mat4
    // https://www.shadertoy.com/view/3s33zj for details.
    normalFromMat4( a ){
        // Only difference from adjoint() is these indices.
        const a00 = a[0];
        const a01 = a[1];
        const a02 = a[2];

        const a10 = a[4];
        const a11 = a[5];
        const a12 = a[6];

        const a20 = a[8];
        const a21 = a[9];
        const a22 = a[10];

        this[0] = a11 * a22 - a12 * a21;
        this[1] = a02 * a21 - a01 * a22;
        this[2] = a01 * a12 - a02 * a11;

        this[3] = a12 * a20 - a10 * a22;
        this[4] = a00 * a22 - a02 * a20;
        this[5] = a02 * a10 - a00 * a12;

        this[6] = a10 * a21 - a11 * a20;
        this[7] = a01 * a20 - a00 * a21;
        this[8] = a00 * a11 - a01 * a10;
        return this;
    }
    // #endregion
}

class Vec3 extends Array{
    constructor( v=null ){
        super( 3 );
        if( v?.length === 3 ) this.copy( v );
        else                  this.zero();
    }

    // #region SETTERS
    zero(){
        this[0] = 0;
        this[1] = 0;
        this[2] = 0;
        return this;
    }

    copy( v ){
        this[0] = v[0];
        this[1] = v[1];
        this[2] = v[2];
        return this;
    }
    // #endregion

    // #region FROM OPS
    fromSub( a, b ){
        this[ 0 ] = a[ 0 ] - b[ 0 ];
        this[ 1 ] = a[ 1 ] - b[ 1 ];
        this[ 2 ] = a[ 2 ] - b[ 2 ];
        return this;
    }
    // fromScale( v, s ){
    //     this[ 0 ] = v[0] * s;
    //     this[ 1 ] = v[1] * s;
    //     this[ 2 ] = v[2] * s;
    //     return this;
    // }

    fromNorm( v ){
        let mag = Math.sqrt( v[ 0 ]**2 + v[ 1 ]**2 + v[ 2 ]**2 );
        if( mag == 0 ) return this;

        mag       = 1 / mag;
        this[ 0 ] = v[ 0 ] * mag;
        this[ 1 ] = v[ 1 ] * mag;
        this[ 2 ] = v[ 2 ] * mag;
        return this;
    }

    fromCross( a, b ){
        const ax = a[0], ay = a[1], az = a[2],
              bx = b[0], by = b[1], bz = b[2];

        this[ 0 ] = ay * bz - az * by;
        this[ 1 ] = az * bx - ax * bz;
        this[ 2 ] = ax * by - ay * bx;
        return this;
    }
    // #endregion

    // #region OPERATORS
    add( a ){
        this[ 0 ] += a[ 0 ];
        this[ 1 ] += a[ 1 ];
        this[ 2 ] += a[ 2 ];
        return this;
    }

    sub( v ){
        this[ 0 ] -= v[ 0 ];
        this[ 1 ] -= v[ 1 ];
        this[ 2 ] -= v[ 2 ];
        return this;
    }

    scale( v ){
        this[ 0 ] *= v;
        this[ 1 ] *= v;
        this[ 2 ] *= v;
        return this;
    }

    scaleThenAdd( s, v ){
        this[ 0 ] += v[0] * s;
        this[ 1 ] += v[1] * s;
        this[ 2 ] += v[2] * s;
        return this;
    }

    cross( b ){
        const ax = this[0], ay = this[1], az = this[2],
              bx = b[0],    by = b[1],    bz = b[2];

        this[ 0 ] = ay * bz - az * by;
        this[ 1 ] = az * bx - ax * bz;
        this[ 2 ] = ax * by - ay * bx;
        return this;
    }
    
    norm(){
        let mag = Math.sqrt( this[0]**2 + this[1]**2 + this[2]**2 );
        if( mag != 0 ){
            mag        = 1 / mag;
            this[ 0 ] *= mag;
            this[ 1 ] *= mag;
            this[ 2 ] *= mag;
        }
        return this;
    }
    // #endregion

    // #region STATIC OPS
    static len( a ){ return Math.sqrt( a[ 0 ]**2 + a[ 1 ]**2 + a[ 2 ]** 2 ); }
    static lenSqr( a ){ return a[ 0 ]**2 + a[ 1 ]**2 + a[ 2 ]** 2; }

    static dist( a, b ){ return Math.sqrt( (a[ 0 ]-b[ 0 ]) ** 2 + (a[ 1 ]-b[ 1 ]) ** 2 + (a[ 2 ]-b[ 2 ]) ** 2 ); }
    static distSqr( a, b ){ return (a[ 0 ]-b[ 0 ]) ** 2 + (a[ 1 ]-b[ 1 ]) ** 2 + (a[ 2 ]-b[ 2 ]) ** 2; }

    static dot( a, b ) { return a[ 0 ] * b[ 0 ] + a[ 1 ] * b[ 1 ] + a[ 2 ] * b[ 2 ]; }
    static cross( a, b, out=new Vec3() ){
        const ax = a[0], ay = a[1], az = a[2],
              bx = b[0], by = b[1], bz = b[2];

        out[ 0 ] = ay * bz - az * by;
        out[ 1 ] = az * bx - ax * bz;
        out[ 2 ] = ax * by - ay * bx;
        return out;
    }
    // #endregion
}

class Quat extends Array{
    constructor( v=null ){
        super( 4 );
        if( v?.length === 4 ) this.copy( v );
        else                  this.identity();
    }

    // #region SETTERS
    identity(){
        this[0] = 0;
        this[1] = 0;
        this[2] = 0;
        this[3] = 1;
        return this;
    }

    copy( v ){
        this[0] = v[0];
        this[1] = v[1];
        this[2] = v[2];
        this[3] = v[3];
        return this;
    }
    // #endregion

    // #region OPERATIONS
    /** Multiple Quaternion onto this Quaternion */
    mul( q ){
        const ax = this[0], ay = this[1], az = this[2], aw = this[3],
              bx = q[0],    by = q[1],    bz = q[2],    bw = q[3];
        this[ 0 ] = ax * bw + aw * bx + ay * bz - az * by;
        this[ 1 ] = ay * bw + aw * by + az * bx - ax * bz;
        this[ 2 ] = az * bw + aw * bz + ax * by - ay * bx;
        this[ 3 ] = aw * bw - ax * bx - ay * by - az * bz;
        return this;
    }

    /** PreMultiple Quaternions onto this Quaternion */
    pmul( q ){
        const ax = q[0],    ay  = q[1],     az = q[2],    aw = q[3],
              bx = this[0], by  = this[1],  bz = this[2], bw = this[3];
        this[ 0 ] = ax * bw + aw * bx + ay * bz - az * by;
        this[ 1 ] = ay * bw + aw * by + az * bx - ax * bz;
        this[ 2 ] = az * bw + aw * bz + ax * by - ay * bx;
        this[ 3 ] = aw * bw - ax * bx - ay * by - az * bz;
        return this;
    }

    norm(){
        let len =  this[0]**2 + this[1]**2 + this[2]**2 + this[3]**2;
        if( len > 0 ){
            len = 1 / Math.sqrt( len );
            this[ 0 ] *= len;
            this[ 1 ] *= len;
            this[ 2 ] *= len;
            this[ 3 ] *= len;
        }
        return this;
    }

    invert(){
        const a0  = this[ 0 ],
              a1  = this[ 1 ],
              a2  = this[ 2 ],
              a3  = this[ 3 ],
              dot = a0*a0 + a1*a1 + a2*a2 + a3*a3;
        
        if(dot == 0){ this[0] = this[1] = this[2] = this[3] = 0; return this }

        const invDot = 1.0 / dot; // let invDot = dot ? 1.0/dot : 0;
        this[ 0 ]    = -a0 * invDot;
        this[ 1 ]    = -a1 * invDot;
        this[ 2 ]    = -a2 * invDot;
        this[ 3 ]    =  a3 * invDot;
        return this;
    }
    // #endregion

    // #region CONVERT
    fromMat3( m ){
        // https://github.com/toji/gl-matrix/blob/master/src/gl-matrix/quat.js#L305
        // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes
        // article "Quat Calculus and Fast Animation".
        let fRoot;
        const fTrace = m[0] + m[4] + m[8];

        if( fTrace > 0.0 ){
            // |w| > 1/2, may as well choose w > 1/2
            fRoot	= Math.sqrt( fTrace + 1.0 );  // 2w
            this[3]	= 0.5 * fRoot;
            
            fRoot	= 0.5 / fRoot;  // 1/(4w)
            this[0]	= (m[5]-m[7])*fRoot;
            this[1]	= (m[6]-m[2])*fRoot;
            this[2]	= (m[1]-m[3])*fRoot;
        }else{
            // |w| <= 1/2
            let i = 0;

            if ( m[4] > m[0] )		i = 1;
            if ( m[8] > m[i*3+i] )	i = 2;
            
            const j = (i+1) % 3;
            const k = (i+2) % 3;

            fRoot	= Math.sqrt( m[i*3+i] - m[j*3+j] - m[k*3+k] + 1.0);
            this[ i ]	= 0.5 * fRoot;

            fRoot	= 0.5 / fRoot;
            this[ 3 ]	= ( m[j*3+k] - m[k*3+j] ) * fRoot;
            this[ j ]	= ( m[j*3+i] + m[i*3+j] ) * fRoot;
            this[ k ]	= ( m[k*3+i] + m[i*3+k] ) * fRoot;
        }
        return this;
    }
    // #endregion
}

// #endregion

/*
INTERPOLATE BETWEEN PHYSICS FRAMES
// Assume we have an object representing the cube
let cube = {
    position: { x: 0, y: 0, z: 0 }, // Current position of the cube
    velocity: { x: 5, y: 0, z: 0 }  // Velocity of the cube (5 units per second in the x-direction)
};

// Physics step size (1/30th of a second)
const physicsStep = 1 / 30; // Time step for physics engine updates
let lastPhysicsTime = 0; // Keeps track of the last time physics was updated
let lastRenderTime = 0; // Keeps track of the last render time

// Function to simulate the physics engine (updates position based on velocity)
function updatePhysics(deltaTime) {
    // Update position based on velocity
    cube.position.x += cube.velocity.x * deltaTime;
}

// Function for interpolation between physics steps
function interpolatePosition(t, lastPhysicsPos, currentPhysicsPos) {
    // Linear interpolation between the last and current physics positions
    return lastPhysicsPos + (currentPhysicsPos - lastPhysicsPos) * t;
}

// Simulate the game loop (running at 60 FPS)
function gameLoop(timestamp) {
    const deltaTime = (timestamp - lastRenderTime) / 1000; // Time since the last render (in seconds)
    lastRenderTime = timestamp;

    // Simulate physics update if enough time has passed
    if (timestamp - lastPhysicsTime >= physicsStep * 1000) {
        updatePhysics(physicsStep); // Update physics for the cube
        lastPhysicsTime = timestamp;
    }

    // Interpolate the position of the cube based on the time since the last physics update
    const interpolationTime = (timestamp - lastPhysicsTime) / (physicsStep * 1000); // Time from last physics update
    const interpolatedX = interpolatePosition(interpolationTime, cube.position.x - cube.velocity.x * physicsStep, cube.position.x);

    // Render the cube (position it based on the interpolated position)
    renderCube(interpolatedX);

    // Call the next frame
    requestAnimationFrame(gameLoop);
}

// Function to render the cube (for this example, just logging position)
function renderCube(x) {
    console.log("Cube position: ", x);
}

// Start the game loop
requestAnimationFrame(gameLoop);
*/


/* COLLIDERS

	bool SphereCollider::isInside(const glm::vec3 & point, Contact * contact) const
	{
		const glm::vec3 & diff = point - m_position;
		float dist = glm::length(diff);

		float t = CollisionDetector::COLLISION_THRESHOLD;

		if (dist < (m_radius + t)) {

			contact->normal = glm::normalize(diff);
			contact->penetration = dist - (m_radius + t);
			contact->point = contact->normal * (m_radius + t);

			return true;
		}

		return false;
	}

    bool CollisionDetector::SphereAndSphere(SphereCollider * a, SphereCollider * b, CollisionData * data)
	{
		glm::vec3 pa = glm::vec3(a->transform().world() * glm::vec4(a->m_position, 1.0f));
		glm::vec3 pb = glm::vec3(b->transform().world() * glm::vec4(b->m_position, 1.0f));

		glm::vec3 ab = pa - pb;
		float length = glm::length(ab);

		if (length <= 0.0f || length > a->m_radius + b->m_radius)
			return false;

		Contact * contact = new Contact;

		contact->normal = glm::normalize(ab);
		contact->point = pa + 0.5f * ab;
		contact->penetration = a->m_radius + b->m_radius - length;

		data->contacts.push_back(contact);

		return true;
	}

	bool CollisionDetector::SphereAndPlane(SphereCollider * sphere, PlaneCollider * plane, CollisionData * data)
	{
		glm::vec3 position = glm::vec3(sphere->transform().world() * glm::vec4(sphere->m_position, 1.0f));

		float distance = glm::dot(plane->m_normal, position) - sphere->m_radius - plane->m_d;

		if (distance >= 0)
			return false;

		Contact * contact = new Contact;

		contact->normal = plane->m_normal;
		contact->point = position - plane->m_normal * (distance + sphere->m_radius);
		contact->penetration = -distance;

		data->contacts.push_back(contact);

		return true;
	}

*/

</script></body></html>