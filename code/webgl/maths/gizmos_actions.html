<!DOCTYPE html><html lang="en"><head><title></title></head>
<style>canvas{ display:block; } body, html { padding:0px; margin:0px; width:100%; height:100%; }</style>
<body><script src="../../../import-map.js"></script><script type="module">
// #region IMPORTS
import useThreeWebGL2, { THREE, useDarkScene, useVisualDebug } from '@lib/useThreeWebGL2.js';

import DynLinesMesh     from '@lib/meshes/DynLineMesh.js';
import ShapePointsMesh  from '@lib/meshes/ShapePointsMesh.js';
import facedCube        from '@lib/meshes/FacedCube.js';

// https://tweakpane.github.io/docs/
// https://tweakpane.github.io/docs/plugins/#essentials
// https://github.com/tweakpane/plugin-essentials - Radio Grid
// https://github.com/tweakpane/plugin-camerakit
import { Pane }                 from '@tp/tweakpane/tweakpane-4.0.4.min.js';
// import * as TweakpaneEssentials from '@tp/tweakpane/tweakpane-plugin-essentials-0.2.1.min.js';
// #endregion

// #region MAIN
let App   = useDarkScene( useThreeWebGL2() );
let Debug = {};
let Ref   = {
    // -----------------------------------
    // World

    // -----------------------------------
    // Pane State
    action : 'lineMove',
};

window.addEventListener( 'load', async ()=>{
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	App.sphericalLook( 45, 20, 10 );
    Debug = await useVisualDebug( App );

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // SETUP
    Ref.cube = facedCube();
    Ref.cube.position.set( 0, 1, 0 );
    App.scene.add( Ref.cube );

    Ref.act = new ActionManager( App.scene, App.camera, App.renderer, App.camCtrl )
        .addAction( 'lineMove', new LineMoveAction() )
        .addAction( 'planeMove', new PlaneMoveAction() )
    ;

    startLineMove();
    // startPlaneMove();

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // App.createRenderLoop( onPreRender ).start();
    App.renderLoop();
    buildUI();
});

function onPreRender( dt, et ){}

async function buildUI(){
    appendGithubLink( false );
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    const p = new Pane();
    // p.registerPlugin( TweakpaneEssentials );
    // p.on( 'change', e=>{});
    
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    const f = p.addFolder({ title: 'Actions', expanded: true });
    f.addButton({ title: 'Line Move' }).on( 'click', startLineMove );
    f.addButton({ title: 'Plane Move' }).on( 'click', startPlaneMove );

    // const actions = [ {t:'LineRay', v:'lineRay'}, {t:'misc', v:'misc'}, ];
    // f.addBinding( Ref, 'action', {
    //         view        : 'radiogrid',
    //         groupName   : 'actionName',
    //         label       : 'Actions',
    //         size        : [ 1, actions.length ],
    //         cells       : ( x, y ) =>{ 
    //             return {
    //                 title: actions[y * 1 + x].t,
    //                 value: actions[y * 1 + x].v,
    //             }
    //         },
    //     })
    //     .on( 'change', e => {
    //         console.log(e);
    //         switch( e.value ){
    //             case 'lineRay': startLineRay(); return;
    //         }
    //     });

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    Ref.pane = p;
}

function startLineMove(){
    const DIST  = 5;    // Distance from point to move fwd & back
    
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Random rotation
    const q = new Quat().fromPolar(
        180 * ( Math.random() * 2 - 1 ),
        90 * ( Math.random() * 2 - 1 ),
    );

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Compute start and end pos of a segment
    const pos   = new Vec3( Ref.cube.position.toArray() );
    const fwd   = new Vec3().fromQuat( q );
    const sPos  = pos.clone().scaleThenAdd( DIST, fwd );
    const ePos  = pos.clone().scaleThenAdd( DIST, fwd.negate() );

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // DEBUG
    // Debug.pnt.add( sPos, 0x00ff00, 3 );
    // Debug.pnt.add( ePos, 0xff0000, 3 );
    // Debug.ln.add( sPos, ePos, 0x00ff00 );
    
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    const props = {
        startPos    : sPos,
        endPos      : ePos,
    };

    Ref.act.useAction( 'lineMove', new LineMovePreview(), Ref.cube, props );
}

function startPlaneMove(){
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Random rotation
    const q = new Quat().fromPolar(
        180 * ( Math.random() * 2 - 1 ),
        90 * ( Math.random() * 2 - 1 ),
    );

    // // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // // Compute start and end pos of a segment
    const pos   = new Vec3( Ref.cube.position.toArray() );
    const fwd   = new Vec3().fromQuat( q ).norm();
    const rit   = new Vec3().fromCross( [0,1,0], fwd ); //.norm();
    const up    = new Vec3().fromCross( fwd, rit ).norm();

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // DEBUG
    // Debug.ln.add( pos, pos.clone().scaleThenAdd( 2, fwd ), 0xff0000 );
    // Debug.ln.add( pos, pos.clone().scaleThenAdd( 2, rit.norm() ), 0x00ff00 );
    // Debug.ln.add( pos, pos.clone().scaleThenAdd( 2, up ), 0x0000ff );
    
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    const props = {
        origin   : pos,
        fwdDir   : fwd,
        upDir    : up,
    };

    Ref.act.useAction( 'planeMove', new PlaneMovePreview(), Ref.cube, props );
}

// #endregion

// #region MANAGER

// A simple "state machine" to manage pointer events with various actions
// React people, this has nothing to do with "useState", its a gamedev
// design pattern for controlling routing input, active scenes, modes, etc.
class ActionManager{
    // #region MAIN
    renderer    = null; // 3JS Renderer
    scene       = null; // 3JS Scene
    camera      = null; // 3JS Camera
    camCtrl     = null; // 3JS Camera controller ( disable when dragging )
    
    active      = true; // If manager is enabled
    dragging    = false;// Indicate that draggin in progress

    object      = null; // Object to apply transform
    action      = null; // Transform Action
    preview     = null; // Renderer for Action

    actions     = {};   // Actions registered for use

    dynLines    = new DynLinesMesh();     // Reusable way to generate lines
    dynPoints   = new ShapePointsMesh();  // Reusable way to generate points
    ray         = new Ray();              // Reusable ray for intersection testing

    constructor( scene, camera, renderer, camCtrl ){
        this.renderer   = renderer ;
        this.scene      = scene;
        this.camera     = camera;
        this.camCtrl    = camCtrl;
        
        this.startEvents();

        this.scene.add( this.dynLines );
        this.scene.add( this.dynPoints );
    }
    // #endregion

    // #region SETERS / GETTERS
    getObjectPos(){ return this.object ? this.object.position.toArray() : [0,0,0]; }
    setObjectPos( v ){ if( this.object ) this.object.position.fromArray( v ); }
    // #endregion

    // #region EVENT HANDLERS & METHODS
    startEvents(){
        const c = this.renderer.domElement;
        c.addEventListener( 'pointerdown',   this.onPointerDown );
        c.addEventListener( 'pointermove',   this.onPointerMove );
        c.addEventListener( 'pointerup',     this.onPointerUp );
        c.addEventListener( 'pointercancel', this.onPointerCancel );
        return this;
    }

    disableEvents(){
        const c = this.renderer.domElement;
        c.removeEventListener( 'pointerdown',   this.onPointerDown );
        c.removeEventListener( 'pointermove',   this.onPointerMove );
        c.removeEventListener( 'pointerup',     this.onPointerUp );
        c.removeEventListener( 'pointercancel', this.onPointerCancel );
        return this;
    }

    onPointerDown = e=>{
        if( !this.active || !this.action ) return;

        // Check if dragging action will started
        if( this.action.onDown( this, e ) ){
            this.dragging           = true;
            this.camCtrl.enabled    = false;
            this.renderer.domElement.setPointerCapture( e.pointerId );
            this.preview.render( this );
        }
    }

    onPointerMove = e=>{
        if( this.dragging && this.action.onMove( this, e ) ){
            this.preview.render( this );
        }
    }

    onPointerUp = e=>{
        if( this.dragging ){
            this.dragging           = false;
            this.camCtrl.enabled    = true;
            this.renderer.domElement.releasePointerCapture( e.pointerId );

            if( this.action?.onUp( this, e ) ) this.preview.render( this );
        }
    }

    onPointerCancel = e=>{
        console.log( 'PointerCancel' );

        if( this.dragging ){
            this.dragging           = false;
            this.camCtrl.enabled    = true;
            this.renderer.domElement.releasePointerCapture( e.pointerId );
        }
    }
    // #endregion

    // #region ACTION MANAGEMENT
    addAction( name, o ){
        this.actions[ name ] = o;
        return this;
    }

    useAction( name, prev, obj, props={} ){
        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        // Clean up previous action or previews
        if( this.action )  this.action.unload( this );
        if( this.preview ) this.preview.dispose( this );

        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        // Set Data
        this.action     = this.actions[ name ];
        this.preview    = prev;
        this.object     = obj;

        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        // Initial Objects
        this.action.init( props );
        this.preview
            .init( this, this.action )
            .render( this );

        return this;
    }

    clearAction(){
        this.action     = null;
        this.preview    = null;
        this.object     = null;
        return this;
    }
    // #endregion

    // #region RAY CASTING
    // Compute worldspace ray for actions to use
    getRayFromEvent( e ){
        const size      = new THREE.Vector2();
        const proj      = this.camera.projectionMatrix.toArray();    // Need Projection Matrix
        const camWorld  = this.camera.matrixWorld.toArray();         // World Space Transform of Camera
        this.renderer.getSize( size );                               // Need Size of Canvas

        // Setup Ray
        return this.ray.fromScreenProjection( e.layerX, e.layerY, size.x, size.y, proj, camWorld );
    }
    // #endregion
}

// #endregion

// #region RAY CASTING

class Ray{
    // #region MAIN
    posStart    = new Vec3();   // Origin
    posEnd      = new Vec3();   // 
    direction   = new Vec3();   // Direction from Start to End
    vecLength   = new Vec3();   // Vector Length between start to end
    // #endregion

    // #region SETUP
    fromEndPoints( a, b ){
        this.posStart.copy( a );                    // Starting Point of the Ray
        this.posEnd.copy( b );                      // The absolute end of the ray
        this.vecLength.fromSub( b, a );             // Vector Length
        this.direction.fromNorm( this.vecLength );  // Normalized Vector Length 
        return this;
    }

    fromScreenProjection( x, y, w, h, projMatrix, camMatrix ){
        // http://antongerdelan.net/opengl/raycasting.html
        // Normalize Device Coordinate
        const nx  = x / w * 2 - 1;
        const ny  = 1 - y / h * 2;

        // inverseWorldMatrix = invert( ProjectionMatrix * ViewMatrix ) OR
        // inverseWorldMatrix = localMatrix * invert( ProjectionMatrix ) 
        // const invMatrix = mat4.invert( projMatrix )
        // mat4.mul( camMatrix, invMatrix, invMatrix );
        const invMatrix = new Mat4().fromInvert( projMatrix ).pmul( camMatrix );
        
        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        // https://stackoverflow.com/questions/20140711/picking-in-3d-with-ray-tracing-using-ninevehgl-or-opengl-i-phone/20143963#20143963
        // Clip Cords would be [nx,ny,-1,1];
        const clipNear   = [ nx, ny, -1, 1 ];
        const clipFar    = [ nx, ny, 1, 1 ];

        // using 4d Homogeneous Clip Coordinates
        invMatrix.transformVec4( clipNear );
        invMatrix.transformVec4( clipFar );

        // Normalize by using W component
        for( let i=0; i < 3; i++){
            clipNear[ i ] /= clipNear[ 3 ];
            clipFar [ i ] /= clipFar [ 3 ];
        }

        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        // Final Compute
        this.posStart.copy( clipNear );                         // Starting Point of the Ray
        this.posEnd.copy( clipFar );                            // The absolute end of the ray
        this.vecLength.fromSub( this.posEnd, this.posStart );   // Vector Length
        this.direction.fromNorm( this.vecLength );              // Normalized Vector Length
        return this;
    }
    // #endregion

    // #region GETTERS / SETTERS
    /** Get position of the ray from T Scale of VecLen */
    posAt( t, out = [0,0,0] ){
        // RayVecLen * t + RayOrigin
        // also works lerp( RayOrigin, RayEnd, t )
        out[ 0 ] = this.vecLength[ 0 ] * t + this.posStart[ 0 ];
        out[ 1 ] = this.vecLength[ 1 ] * t + this.posStart[ 1 ];
        out[ 2 ] = this.vecLength[ 2 ] * t + this.posStart[ 2 ];
        return out;
    }

    /** Get position of the ray from distance from origin */
    directionAt( len, out = [0,0,0] ){
        out[ 0 ] = this.direction[ 0 ] * len + this.posStart[ 0 ];
        out[ 1 ] = this.direction[ 1 ] * len + this.posStart[ 1 ];
        out[ 2 ] = this.direction[ 2 ] * len + this.posStart[ 2 ];        
        return out;
    }
    // #endregion

    // #region OPS
    transformMat4( m ){
        this.fromEndPoints( 
            m.transformVec3( this.posStart, [0,0,0] ), 
            m.transformVec3( this.posEnd,   [0,0,0] ),
        );
        return this;
    }
    // #endregion
}


class NearSegmentResult{
    segPosition = [0,0,0];
    rayPosition = [0,0,0];
    distanceSq  = 0;
    distance    = 0;
}

/** Returns [ T of Segment, T of RayLen ] */
function nearSegment( ray, p0, p1, results=null){
    // http://geomalgorithms.com/a07-_distance.html
    const u = new Vec3( p1 ).sub( p0 );
    const v = ray.vecLength;
    const w = new Vec3( p0 ).sub( ray.posStart );
    const a = Vec3.dot( u, u ); // always >= 0
    const b = Vec3.dot( u, v );
    const c = Vec3.dot( v, v ); // always >= 0
    const d = Vec3.dot( u, w );
    const e = Vec3.dot( v, w );
    const D = a * c - b * b;    // always >= 0

    let tU = 0; // T Of Segment 
    let tV = 0; // T Of Ray

    // Compute the line parameters of the two closest points
    if( D < 0.000001 ){	            // the lines are almost parallel
        tU = 0.0;
        tV = ( b > c ? d/b : e/c ); // use the largest denominator
    }else{
        tU = ( b*e - c*d ) / D;
        tV = ( a*e - b*d ) / D;
    }

    if( tU < 0 || tU > 1 || tV < 0 || tV > 1 ) return null;
    
    // Segment Position : u.scale( tU ).add( p0 )
    // Ray Position :     v.scale( tV ).add( this.origin ) ];
    if( results ){
        // Get SegPostion by lerping the two end points
        const ti = 1 - tU;
        results.segPosition[ 0 ] = p0[0] * ti + p1[0] * tU;
        results.segPosition[ 1 ] = p0[1] * ti + p1[1] * tU;
        results.segPosition[ 2 ] = p0[2] * ti + p1[2] * tU;
        
        // Get Ray position by using its T Lerp value as well
        ray.posAt( tV, results.rayPosition );
        
        // Distances for intersection testing
        results.distanceSq = Vec3.distSqr( results.segPosition, results.rayPosition );
        results.distance   = Math.sqrt( results.distanceSq );
    }

    return [ tU, tV ]; // The Lerp T values for Segment & Ray
}


function intersectPlane( ray, planePos, planeNorm, hitPos=null ){
    // ((planePos - rayOrigin) dot planeNorm) / ( rayVecLen dot planeNorm )
    // pos = t * rayVecLen + rayOrigin;
    const denom = Vec3.dot( ray.vecLength, planeNorm );         // Dot product of ray Length and plane normal
    if( denom <= 0.000001 && denom >= -0.000001 ) return null;  // abs(denom) < epsilon, using && instead to not perform absolute.

    const v = [
        planePos[0] - ray.posStart[0],
        planePos[1] - ray.posStart[1],
        planePos[2] - ray.posStart[2],
    ];

    const t = Vec3.dot( v, planeNorm ) / denom;

    if( hitPos && t >= 0 ) ray.posAt( t, hitPos );

    return ( t >= 0 )? t : null;
}

// #endregion

// #region ACTIONS

// Object along a line segment
class LineMoveAction{ 
    hitRange = 0.3;         // Distance from segment to start dragging

    startPos = new Vec3();  // Segment start postion
    endPos   = new Vec3();  // Segment end position
    initPos  = new Vec3();  // Initial position on mouse down
    offset   = new Vec3();  // Offset between init pos * obj pos
    pos      = new Vec3();  // current pos

    results  = new NearSegmentResult(); 

    constructor(){}

    init( props ){
        this.startPos.copy( props.startPos );
        this.endPos.copy( props.endPos );
        return this;
    }

    unload( mgt ){}

    onDown( mgt, e ){
        const ray = mgt.getRayFromEvent( e );
        // Debug.ln.add( ray.posStart, ray.posEnd, 0x00ffff );

        if( nearSegment( ray, this.endPos, this.startPos, this.results )
            && this.results.distance <= this.hitRange ){

            this.initPos.copy( this.results.segPosition );
            this.offset.fromSub( mgt.getObjectPos(), this.initPos );

            return true;
        }

        return false;
    }

    onMove( mgt, e ){
        const ray = mgt.getRayFromEvent( e );
        if( nearSegment( ray, this.endPos, this.startPos, this.results ) ){            

            this.pos.fromAdd( this.results.segPosition, this.offset );

            // Debug.pnt.reset();
            // Debug.pnt.add( this.results.segPosition, 0xff00ff, 5 );
            // Debug.pnt.add( this.pos, 0xffffff, 5 );

            // const v = new Vec3().fromAdd( this.offset, this.initPos );
            // Debug.pnt.add( v, 0x0000ff, 5 );

            mgt.setObjectPos( this.pos );
            return true;
        }

        return false;
    }

    onUp( mgt, e ){ return true; }
}

// Move object along a plane
class PlaneMoveAction{
    hitRange    = 3;
    pos         = new Vec3();
    fwdDir      = new Vec3( 0, 0, 1 );
    upDir       = new Vec3( 0, 1, 0 );
    origin      = new Vec3( 0, 0, 0 );
    constructor(){}

    init( props ){
        this.fwdDir.copy( props.fwdDir );
        this.upDir.copy( props.upDir );
        this.origin.copy( props.origin );
        return this;
    }

    unload( mgt ){}

    onDown( mgt, e ){
        const ray = mgt.getRayFromEvent( e );
        const v   = new Vec3();
        
        if( intersectPlane( ray, this.origin, this.fwdDir, v ) ){
            // Debug.pnt.reset();
            // Debug.ln.reset();
            
            // Debug.pnt.add( v, 0x00ff00, 4  );
            // Debug.ln.add( this.origin, this.origin.clone().scaleThenAdd( 4, this.fwdDir ), 0x00ff00 );
            // console.log( Vec3.dist( v, this.origin ) )

            if( Vec3.dist( v, this.origin ) <= this.hitRange ){
                return true;
            }
        }

        return false;
    }

    onMove( mgt, e ){
        const ray = mgt.getRayFromEvent( e );
        if( intersectPlane( ray, this.origin, this.fwdDir, this.pos ) ){
            mgt.setObjectPos( this.pos );
            return true;
        }
        return false;
    }

    onUp( mgt, e ){ 
        this.origin.copy( this.pos );
        return true;
    }
}

// https://github.com/sketchpunklabs/gizmos/blob/main/src/actions/PlaneMovement.ts
// https://github.com/sketchpunklabs/gizmos/blob/main/src/gizmos/RotationGizmoV2.ts

// #endregion 

// #region PREVIEWS / RENDERERS

// Visualize Line Move Action
class LineMovePreview{
    action = null;
    constructor(){}

    init( mgt, action ){
        this.action = action;
        return this;
    }

    dispose( mgt ){
        mgt.dynPoints.reset();
        mgt.dynLines.reset();
        return true;
    }

    render( mgt ){
        const act = this.action;
        const pnt = mgt.dynPoints.reset();
        const ln  = mgt.dynLines.reset();
        
        pnt.add( act.startPos, 0x00ff00 );
        pnt.add( act.endPos, 0xff0000 );
        if( mgt.dragging ) pnt.add( act.initPos, 0x00ffff );

        ln.add( act.startPos, act.endPos, 0x00ff00, 0xff0000 );
    }
}

// Visualize Plane Move Action
class PlaneMovePreview{
    mesh    = null;
    action  = null;
    constructor(){}

    init( mgt, action ){
        this.action = action;

        // Add mesh to the scene if not available
        if( !this.mesh ){
            this.mesh = CircleGridMaterial.createMesh();
            mgt.scene.add( this.mesh );
        }

        // Circle Grid mesh is on the XZ Plane
        // To properly use the Fwd and Up Direction from
        // action will need to fix the initial orientation
        // by applying a fix of 90 deg rotation on the X-Axis
        const fix = new Quat().fromAxisAngle( [1,0,0], Math.PI * 0.5 );
        const q   = new Quat()
            .fromLook( action.fwdDir, action.upDir )
            .mul( fix )
            .norm();

        this.mesh.quaternion.fromArray( q );
        this.mesh.position.fromArray( action.origin );
        this.mesh.visible = true;

        // Debug.ln.add( action.origin, action.origin.clone().scaleThenAdd( 4, action.fwdDir ), 0x00ff00 );

        return this;
    }

    dispose( mgt ){
        // TODO - Adding and removing the preview mesh
        // when switching actions might not be the best
        // way to handle it. Depending on the App, cacheing
        // the object is a good idea.
        if( this.mesh ){
            mgt.scene.remove( this.mesh );
            this.mesh.geometry.dispose();
            this.mesh = null;
        }
        return true;
    }

    render( mgt ){
        const act = this.action;
        const ln  = mgt.dynLines.reset();

        if( mgt.dragging ){
            ln.add( act.origin, act.pos, 0x000000 );
        }else{
            this.mesh.position.fromArray( act.origin );
        }   
    }
}

// Render a special grid onto a quad
class CircleGridMaterial extends THREE.RawShaderMaterial{
    constructor(){
        super();

        this.glslVersion        = THREE.GLSL3;
        this.side               = THREE.DoubleSide;
        this.depthTest          = true;
        this.transparent 	    = true;
        this.alphaToCoverage    = true;

        this.uniforms           = {
            oRadius     : { value: 0.49 },
            iRadius     : { value: 0.47 },
            gridSize    : { value: 0.1 },
            lineSize    : { value: 0.1 },
            color       : { value: new THREE.Color( '#202020' ) },
        };

        this.vertexShader = `
        in	vec3    position;
        in  vec3    normal;
        in	vec2    uv;
        
        // uniform highp vec3 cameraPosition;

        uniform mat4  modelMatrix;
        uniform mat4  viewMatrix;
        uniform mat4  projectionMatrix;

        out vec3 fragLPos;
        out vec3 fragSPos;

        // ############################################################

        vec3 decomposeScaleFromMat4( mat4 m ){
            return vec3(
                length( vec3( m[0][0], m[0][1], m[0][2] ) ),
                length( vec3( m[1][0], m[1][1], m[1][2] ) ),
                length( vec3( m[2][0], m[2][1], m[2][2] ) )
            );
        }

        // ############################################################

        void main(){
            vec4 wPos       = modelMatrix * vec4( position, 1.0 );
            
            fragLPos        = position.xyz;
            fragSPos        = position.xyz * decomposeScaleFromMat4( modelMatrix );

            gl_Position     = projectionMatrix * viewMatrix * wPos;
        }`;

        this.fragmentShader = `precision mediump float;
        in vec3 fragLPos;
        in vec3 fragSPos;
        out vec4 outColor;

        uniform float oRadius;
        uniform float iRadius;
        uniform float gridSize;
        uniform float lineSize;
        uniform vec3  color;

        // #####################################################################

        float circle( float radius, float len, float dxdy ){
            // float dxdy = fwidth( len );
            return 1.0 - smoothstep( radius-dxdy, radius+dxdy, len );
        }

        float ring( float oRadius, float iRadius, float len, float dxdy ){
            // float dxdy   = fwidth( len );
            float omask  = smoothstep( oRadius-dxdy, oRadius+dxdy, len );
            float imask  = smoothstep( iRadius-dxdy, iRadius+dxdy, len );
            return imask - omask;
        }

        // https://bgolus.medium.com/the-best-darn-grid-shader-yet-727f9278b9d8
        // https://www.shadertoy.com/view/mdVfWw
        float pristineGrid( vec2 uv, vec2 lineWidth ){
            vec2 ddx         = dFdx( uv );
            vec2 ddy         = dFdy( uv );
            vec2 uvDeriv     = vec2(
                length( vec2( ddx.x, ddy.x ) ), 
                length( vec2( ddx.y, ddy.y ) )
            );
            
            bvec2 invertLine = bvec2( lineWidth.x > 0.5, lineWidth.y > 0.5 );
            
            vec2 targetWidth = vec2(
                invertLine.x ? 1.0 - lineWidth.x : lineWidth.x,
                invertLine.y ? 1.0 - lineWidth.y : lineWidth.y
            );

            vec2 drawWidth = clamp( targetWidth, uvDeriv, vec2(0.5) );
            vec2 lineAA    = uvDeriv * 1.5;
            vec2 gridUV    = abs(fract(uv) * 2.0 - 1.0);
            gridUV.x       = invertLine.x ? gridUV.x : 1.0 - gridUV.x;
            gridUV.y       = invertLine.y ? gridUV.y : 1.0 - gridUV.y;
            
            vec2 grid2 = smoothstep(drawWidth + lineAA, drawWidth - lineAA, gridUV );
            grid2     *= clamp( targetWidth / drawWidth, 0.0, 1.0 );
            grid2      = mix(grid2, targetWidth, clamp( uvDeriv * 2.0 - 1.0, 0.0, 1.0 ) );
            grid2.x    = invertLine.x ? 1.0 - grid2.x : grid2.x;
            grid2.y    = invertLine.y ? 1.0 - grid2.y : grid2.y;
            
            return mix( grid2.x, 1.0, grid2.y );
        }

        // #####################################################################

        void main(){
            // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            float len  = length( fragLPos.xz );
            float dxdy = fwidth( len );

            float maskCircle = circle( 0.01, len, dxdy );

            // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            // Grid Mask
            float maskGrid  = pristineGrid( fragSPos.xz / gridSize, vec2( lineSize ) );
            // outColor.rgb    = vec3( maskGrid );

            // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            // Mask to cut the grid
            float mRadius  = iRadius * 0.5 + oRadius * 0.5;
            float maskCut  = 1.0 - step( mRadius, len );
            // outColor.rgb   = vec3( maskCut );

            // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            // Ring Mask
            float maskRing = ring( oRadius, iRadius, len, dxdy );
            // outColor.rgba  = vec4( maskRing );

            // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            outColor.rgba  = vec4( max( maskCircle, max( maskRing, maskGrid * maskCut )) );
            outColor.rgb  *= color;
        }`;
    }

    static createMesh(){
        const geo = new THREE.PlaneGeometry( 1, 1 );
        geo.rotateX( -Math.PI * 0.5 );  // Plane normal points up
        
        const mesh = new THREE.Mesh( geo, new CircleGridMaterial() );
        mesh.scale.setScalar( 6 );
        return mesh;
    }
}

// #endregion

// #region MATHS

class Vec3 extends Array{
    constructor( v=null ){
        super( 3 );
        if( v?.length === 3 ) this.copy( v );
        else                  this.zero();
    }

    // #region SETTERS
    zero(){
        this[0] = 0;
        this[1] = 0;
        this[2] = 0;
        return this;
    }

    copy( v ){
        this[0] = v[0];
        this[1] = v[1];
        this[2] = v[2];
        return this;
    }

    xyz( x, y, z ){
        this[0] = x;
        this[1] = y;
        this[2] = z;
        return this;
    }
    // #endregion

    // #region GETTERS
    get len(){ return Math.sqrt( this[ 0 ]**2 + this[ 1 ]**2 + this[ 2 ]**2 ); }
    get lenSqr(){ return  this[ 0 ]**2 + this[ 1 ]**2 + this[ 2 ]**2; }

    clone(){ return new Vec3( this ); }
    // #endregion

    // #region FROM OPS
    fromAdd( a, b ){
        this[ 0 ] = a[ 0 ] + b[ 0 ];
        this[ 1 ] = a[ 1 ] + b[ 1 ];
        this[ 2 ] = a[ 2 ] + b[ 2 ];
        return this;
    }

    fromSub( a, b ){
        this[ 0 ] = a[ 0 ] - b[ 0 ];
        this[ 1 ] = a[ 1 ] - b[ 1 ];
        this[ 2 ] = a[ 2 ] - b[ 2 ];
        return this;
    }
    // fromScale( v, s ){
    //     this[ 0 ] = v[0] * s;
    //     this[ 1 ] = v[1] * s;
    //     this[ 2 ] = v[2] * s;
    //     return this;
    // }

    fromNorm( v ){
        let mag = Math.sqrt( v[ 0 ]**2 + v[ 1 ]**2 + v[ 2 ]**2 );
        if( mag == 0 ) return this;

        mag       = 1 / mag;
        this[ 0 ] = v[ 0 ] * mag;
        this[ 1 ] = v[ 1 ] * mag;
        this[ 2 ] = v[ 2 ] * mag;
        return this;
    }

    fromCross( a, b ){
        const ax = a[0], ay = a[1], az = a[2],
              bx = b[0], by = b[1], bz = b[2];

        this[ 0 ] = ay * bz - az * by;
        this[ 1 ] = az * bx - ax * bz;
        this[ 2 ] = ax * by - ay * bx;
        return this;
    }

    fromQuat( q, v=[0,0,1] ){
        const qx = q[0], qy = q[1], qz = q[2], qw = q[3],
              vx = v[0], vy = v[1], vz = v[2],
              x1 = qy * vz - qz * vy,
              y1 = qz * vx - qx * vz,
              z1 = qx * vy - qy * vx,
              x2 = qw * x1 + qy * z1 - qz * y1,
              y2 = qw * y1 + qz * x1 - qx * z1,
              z2 = qw * z1 + qx * y1 - qy * x1;
        this[ 0 ] = vx + 2 * x2;
        this[ 1 ] = vy + 2 * y2;
        this[ 2 ] = vz + 2 * z2;
        return this;
    }
    // #endregion

    // #region OPERATORS
    add( a ){
        this[ 0 ] += a[ 0 ];
        this[ 1 ] += a[ 1 ];
        this[ 2 ] += a[ 2 ];
        return this;
    }

    sub( v ){
        this[ 0 ] -= v[ 0 ];
        this[ 1 ] -= v[ 1 ];
        this[ 2 ] -= v[ 2 ];
        return this;
    }

    scale( v ){
        this[ 0 ] *= v;
        this[ 1 ] *= v;
        this[ 2 ] *= v;
        return this;
    }

    invScale( v ){
        this[ 0 ] /= v;
        this[ 1 ] /= v;
        this[ 2 ] /= v;
        return this;
    }

    scaleThenAdd( s, v ){
        this[ 0 ] += v[0] * s;
        this[ 1 ] += v[1] * s;
        this[ 2 ] += v[2] * s;
        return this;
    }

    cross( b ){
        const ax = this[0], ay = this[1], az = this[2],
              bx = b[0],    by = b[1],    bz = b[2];

        this[ 0 ] = ay * bz - az * by;
        this[ 1 ] = az * bx - ax * bz;
        this[ 2 ] = ax * by - ay * bx;
        return this;
    }
    
    norm(){
        let mag = Math.sqrt( this[0]**2 + this[1]**2 + this[2]**2 );
        if( mag != 0 ){
            mag        = 1 / mag;
            this[ 0 ] *= mag;
            this[ 1 ] *= mag;
            this[ 2 ] *= mag;
        }
        return this;
    }

    negate(){
        this[ 0 ] = -this[ 0 ];
        this[ 1 ] = -this[ 1 ];
        this[ 2 ] = -this[ 2 ];
        return this;
    }
    // #endregion

    // #region STATIC OPS
    static len( a ){ return Math.sqrt( a[ 0 ]**2 + a[ 1 ]**2 + a[ 2 ]** 2 ); }
    static lenSqr( a ){ return a[ 0 ]**2 + a[ 1 ]**2 + a[ 2 ]** 2; }

    static dist( a, b ){ return Math.sqrt( (a[ 0 ]-b[ 0 ]) ** 2 + (a[ 1 ]-b[ 1 ]) ** 2 + (a[ 2 ]-b[ 2 ]) ** 2 ); }
    static distSqr( a, b ){ return (a[ 0 ]-b[ 0 ]) ** 2 + (a[ 1 ]-b[ 1 ]) ** 2 + (a[ 2 ]-b[ 2 ]) ** 2; }

    static dot( a, b ) { return a[ 0 ] * b[ 0 ] + a[ 1 ] * b[ 1 ] + a[ 2 ] * b[ 2 ]; }
    static cross( a, b, out=new Vec3() ){
        const ax = a[0], ay = a[1], az = a[2],
              bx = b[0], by = b[1], bz = b[2];

        out[ 0 ] = ay * bz - az * by;
        out[ 1 ] = az * bx - ax * bz;
        out[ 2 ] = ax * by - ay * bx;
        return out;
    }
    // #endregion
}

class Quat extends Array{
    constructor( v=null ){
        super( 4 );
        if( v?.length === 4 ) this.copy( v );
        else                  this.identity();
    }

    // #region SETTERS
    identity(){
        this[0] = 0;
        this[1] = 0;
        this[2] = 0;
        this[3] = 1;
        return this;
    }

    copy( v ){
        this[0] = v[0];
        this[1] = v[1];
        this[2] = v[2];
        this[3] = v[3];
        return this;
    }
    // #endregion

    // #region OPERATIONS
    /** Multiple Quaternion onto this Quaternion */
    mul( q ){
        const ax = this[0], ay = this[1], az = this[2], aw = this[3],
              bx = q[0],    by = q[1],    bz = q[2],    bw = q[3];
        this[ 0 ] = ax * bw + aw * bx + ay * bz - az * by;
        this[ 1 ] = ay * bw + aw * by + az * bx - ax * bz;
        this[ 2 ] = az * bw + aw * bz + ax * by - ay * bx;
        this[ 3 ] = aw * bw - ax * bx - ay * by - az * bz;
        return this;
    }

    /** PreMultiple Quaternions onto this Quaternion */
    pmul( q ){
        const ax = q[0],    ay  = q[1],     az = q[2],    aw = q[3],
              bx = this[0], by  = this[1],  bz = this[2], bw = this[3];
        this[ 0 ] = ax * bw + aw * bx + ay * bz - az * by;
        this[ 1 ] = ay * bw + aw * by + az * bx - ax * bz;
        this[ 2 ] = az * bw + aw * bz + ax * by - ay * bx;
        this[ 3 ] = aw * bw - ax * bx - ay * by - az * bz;
        return this;
    }

    norm(){
        let len =  this[0]**2 + this[1]**2 + this[2]**2 + this[3]**2;
        if( len > 0 ){
            len = 1 / Math.sqrt( len );
            this[ 0 ] *= len;
            this[ 1 ] *= len;
            this[ 2 ] *= len;
            this[ 3 ] *= len;
        }
        return this;
    }

    invert(){
        const a0  = this[ 0 ],
              a1  = this[ 1 ],
              a2  = this[ 2 ],
              a3  = this[ 3 ],
              dot = a0*a0 + a1*a1 + a2*a2 + a3*a3;
        
        if(dot == 0){ this[0] = this[1] = this[2] = this[3] = 0; return this }

        const invDot = 1.0 / dot; // let invDot = dot ? 1.0/dot : 0;
        this[ 0 ]    = -a0 * invDot;
        this[ 1 ]    = -a1 * invDot;
        this[ 2 ]    = -a2 * invDot;
        this[ 3 ]    =  a3 * invDot;
        return this;
    }
    // #endregion

    // #region FROM OPS
    fromPolar( lon, lat, up=null ){
        lat = Math.max( Math.min( lat, 89.999999 ), -89.999999 ); // Clamp lat, going to 90+ makes things spring around.

        const phi   = ( 90 - lat ) * 0.01745329251, // PI / 180
              theta = lon * 0.01745329251,
              phi_s	= Math.sin( phi ),
              v    = [
                -( phi_s * Math.sin( theta ) ),
                Math.cos( phi ),
                phi_s * Math.cos( theta )
            ];

        this.fromLook( v, up || [0,1,0] );
        return this;
    }

    fromLook( dir, up = [0,1,0] ){
        // Ported to JS from C# example at https://pastebin.com/ubATCxJY
        // TODO, if Dir and Up are equal, a roll happends. Need to find a way to fix this.
        const zAxis	= new Vec3( dir ).norm();                       // Forward
        const xAxis = new Vec3().fromCross( up, zAxis ).norm();     // Right
        const yAxis = new Vec3().fromCross( zAxis, xAxis ).norm();  // Up

        // fromAxis - Mat3 to Quat
        const m00 = xAxis[0], m01 = xAxis[1], m02 = xAxis[2],
              m10 = yAxis[0], m11 = yAxis[1], m12 = yAxis[2],
              m20 = zAxis[0], m21 = zAxis[1], m22 = zAxis[2],
              t   = m00 + m11 + m22;

        let x, y, z, w, s;

        if(t > 0.0){
            s = Math.sqrt(t + 1.0);
            w = s * 0.5 ; // |w| >= 0.5
            s = 0.5 / s;
            x = (m12 - m21) * s;
            y = (m20 - m02) * s;
            z = (m01 - m10) * s;
        }else if((m00 >= m11) && (m00 >= m22)){
            s = Math.sqrt(1.0 + m00 - m11 - m22);
            x = 0.5 * s;// |x| >= 0.5
            s = 0.5 / s;
            y = (m01 + m10) * s;
            z = (m02 + m20) * s;
            w = (m12 - m21) * s;
        }else if(m11 > m22){
            s = Math.sqrt(1.0 + m11 - m00 - m22);
            y = 0.5 * s; // |y| >= 0.5
            s = 0.5 / s;
            x = (m10 + m01) * s;
            z = (m21 + m12) * s;
            w = (m20 - m02) * s;
        }else{
            s = Math.sqrt(1.0 + m22 - m00 - m11);
            z = 0.5 * s; // |z| >= 0.5
            s = 0.5 / s;
            x = (m20 + m02) * s;
            y = (m21 + m12) * s;
            w = (m01 - m10) * s;
        }

        this[ 0 ] = x;
        this[ 1 ] = y;
        this[ 2 ] = z;
        this[ 3 ] = w;
        return this;
    }

    /** Axis must be normlized, Angle in Radians  */
    fromAxisAngle( axis, rad ){ 
        const half = rad * 0.5;
        const s    = Math.sin( half );
        this[ 0 ]  = axis[ 0 ] * s;
        this[ 1 ]  = axis[ 1 ] * s;
        this[ 2 ]  = axis[ 2 ] * s;
        this[ 3 ]  = Math.cos( half );
        return this;
    }
    // #endregion

    // #region CONVERT
    fromMat3( m ){
        // https://github.com/toji/gl-matrix/blob/master/src/gl-matrix/quat.js#L305
        // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes
        // article "Quat Calculus and Fast Animation".
        let fRoot;
        const fTrace = m[0] + m[4] + m[8];

        if( fTrace > 0.0 ){
            // |w| > 1/2, may as well choose w > 1/2
            fRoot	= Math.sqrt( fTrace + 1.0 );  // 2w
            this[3]	= 0.5 * fRoot;
            
            fRoot	= 0.5 / fRoot;  // 1/(4w)
            this[0]	= (m[5]-m[7])*fRoot;
            this[1]	= (m[6]-m[2])*fRoot;
            this[2]	= (m[1]-m[3])*fRoot;
        }else{
            // |w| <= 1/2
            let i = 0;

            if ( m[4] > m[0] )		i = 1;
            if ( m[8] > m[i*3+i] )	i = 2;
            
            const j = (i+1) % 3;
            const k = (i+2) % 3;

            fRoot	= Math.sqrt( m[i*3+i] - m[j*3+j] - m[k*3+k] + 1.0);
            this[ i ]	= 0.5 * fRoot;

            fRoot	= 0.5 / fRoot;
            this[ 3 ]	= ( m[j*3+k] - m[k*3+j] ) * fRoot;
            this[ j ]	= ( m[j*3+i] + m[i*3+j] ) * fRoot;
            this[ k ]	= ( m[k*3+i] + m[i*3+k] ) * fRoot;
        }
        return this;
    }
    // #endregion
}

class Mat4 extends Array{
    // #region CONSTRUCTOR
    constructor(){ 
        super(16);
        this[0]  = 1;
        this[1]  = 0;
        this[2]  = 0;
        this[3]  = 0;

        this[4]  = 0;
        this[5]  = 1;
        this[6]  = 0;
        this[7]  = 0;

        this[8]  = 0;
        this[9]  = 0;
        this[10] = 1;
        this[11] = 0;

        this[12] = 0;
        this[13] = 0;
        this[14] = 0;
        this[15] = 1;
    }
    // #endregion

    // #region FROM OPS
    fromInvert( mat ){
        const a00 = mat[0],  a01 = mat[1],  a02 = mat[2],  a03 = mat[3],
              a10 = mat[4],  a11 = mat[5],  a12 = mat[6],  a13 = mat[7],
              a20 = mat[8],  a21 = mat[9],  a22 = mat[10], a23 = mat[11],
              a30 = mat[12], a31 = mat[13], a32 = mat[14], a33 = mat[15],

              b00 = a00 * a11 - a01 * a10,
              b01 = a00 * a12 - a02 * a10,
              b02 = a00 * a13 - a03 * a10,
              b03 = a01 * a12 - a02 * a11,
              b04 = a01 * a13 - a03 * a11,
              b05 = a02 * a13 - a03 * a12,
              b06 = a20 * a31 - a21 * a30,
              b07 = a20 * a32 - a22 * a30,
              b08 = a20 * a33 - a23 * a30,
              b09 = a21 * a32 - a22 * a31,
              b10 = a21 * a33 - a23 * a31,
              b11 = a22 * a33 - a23 * a32;

        let det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06; // Calculate the determinant

        if( !det ) return this;
        det = 1.0 / det;

        this[0]  = (a11 * b11 - a12 * b10 + a13 * b09) * det;
        this[1]  = (a02 * b10 - a01 * b11 - a03 * b09) * det;
        this[2]  = (a31 * b05 - a32 * b04 + a33 * b03) * det;
        this[3]  = (a22 * b04 - a21 * b05 - a23 * b03) * det;
        this[4]  = (a12 * b08 - a10 * b11 - a13 * b07) * det;
        this[5]  = (a00 * b11 - a02 * b08 + a03 * b07) * det;
        this[6]  = (a32 * b02 - a30 * b05 - a33 * b01) * det;
        this[7]  = (a20 * b05 - a22 * b02 + a23 * b01) * det;
        this[8]  = (a10 * b10 - a11 * b08 + a13 * b06) * det;
        this[9]  = (a01 * b08 - a00 * b10 - a03 * b06) * det;
        this[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
        this[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
        this[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
        this[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
        this[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
        this[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;

        return this;
    }
    // #endregion

    // #region OPERATIONS
    mul( b ){ 
        const   a00 = this[0],	a01 = this[1],	a02 = this[2],	a03 = this[3],
                a10 = this[4],	a11 = this[5],	a12 = this[6],	a13 = this[7],
                a20 = this[8],	a21 = this[9],	a22 = this[10],	a23 = this[11],
                a30 = this[12],	a31 = this[13],	a32 = this[14],	a33 = this[15];

        // Cache only the current line of the second matrix
        let b0  = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
        this[0] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
        this[1] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
        this[2] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
        this[3] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

        b0 = b[4]; b1 = b[5]; b2 = b[6]; b3 = b[7];
        this[4] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
        this[5] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
        this[6] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
        this[7] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

        b0 = b[8]; b1 = b[9]; b2 = b[10]; b3 = b[11];
        this[8] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
        this[9] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
        this[10] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
        this[11] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

        b0 = b[12]; b1 = b[13]; b2 = b[14]; b3 = b[15];
        this[12] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
        this[13] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
        this[14] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
        this[15] = b0*a03 + b1*a13 + b2*a23 + b3*a33;
        return this;	
    }

    pmul( b ){ 
        const   a00 = b[0],	 a01 = b[1],  a02 = b[2],  a03 = b[3],
                a10 = b[4],  a11 = b[5],  a12 = b[6],  a13 = b[7],
                a20 = b[8],  a21 = b[9],  a22 = b[10], a23 = b[11],
                a30 = b[12], a31 = b[13], a32 = b[14], a33 = b[15];

        // Cache only the current line of the second matrix
        let b0  = this[0], b1 = this[1], b2 = this[2], b3 = this[3];
        this[0] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
        this[1] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
        this[2] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
        this[3] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

        b0 = this[4]; b1 = this[5]; b2 = this[6]; b3 = this[7];
        this[4] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
        this[5] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
        this[6] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
        this[7] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

        b0 = this[8]; b1 = this[9]; b2 = this[10]; b3 = this[11];
        this[8]  = b0*a00 + b1*a10 + b2*a20 + b3*a30;
        this[9]  = b0*a01 + b1*a11 + b2*a21 + b3*a31;
        this[10] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
        this[11] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

        b0 = this[12]; b1 = this[13]; b2 = this[14]; b3 = this[15];
        this[12] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
        this[13] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
        this[14] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
        this[15] = b0*a03 + b1*a13 + b2*a23 + b3*a33;
        return this;	
    }
    // #endregion

    // #region TRANSFORMS
    transformVec3( v, out ){
        const x = v[0], y = v[1], z = v[2];
        out    = out || v;
        out[0] = this[0] * x + this[4] * y + this[8]  * z + this[12];
        out[1] = this[1] * x + this[5] * y + this[9]  * z + this[13];
        out[2] = this[2] * x + this[6] * y + this[10] * z + this[14];
        return out;
    }
        
    transformVec4( v, out ){
        const x = v[0], y = v[1], z = v[2], w = v[3];
        out    = out || v;
        out[0] = this[0] * x + this[4] * y + this[8]  * z + this[12] * w;
        out[1] = this[1] * x + this[5] * y + this[9]  * z + this[13] * w;
        out[2] = this[2] * x + this[6] * y + this[10] * z + this[14] * w;
        out[3] = this[3] * x + this[7] * y + this[11] * z + this[15] * w;
        return out;
    }
    // #endregion
}

// #endregion

</script></body></html>