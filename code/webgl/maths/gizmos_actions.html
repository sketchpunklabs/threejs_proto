<!DOCTYPE html><html lang="en"><head><title></title></head>
<style>canvas{ display:block; } body, html { padding:0px; margin:0px; width:100%; height:100%; }</style>
<body><script src="../../../import-map.js"></script><script type="module">
// #region IMPORTS
import useThreeWebGL2, { THREE, useDarkScene, useVisualDebug } from '@lib/useThreeWebGL2.js';

import DynLinesMesh     from '@lib/meshes/DynLineMesh.js';
import ShapePointsMesh  from '@lib/meshes/ShapePointsMesh.js';
import facedCube        from '@lib/meshes/FacedCube.js';

// https://tweakpane.github.io/docs/
// https://tweakpane.github.io/docs/plugins/#essentials
// https://github.com/tweakpane/plugin-essentials - Radio Grid
// https://github.com/tweakpane/plugin-camerakit
import { Pane }                 from '@tp/tweakpane/tweakpane-4.0.4.min.js';
import * as TweakpaneEssentials from '@tp/tweakpane/tweakpane-plugin-essentials-0.2.1.min.js';
// #endregion

// #region MAIN
let App   = useDarkScene( useThreeWebGL2() );
let Debug = {};
let Ref   = {
    // -----------------------------------
    // World

    // -----------------------------------
    // Pane State
    action : 'lineRay',
};

window.addEventListener( 'load', async ()=>{
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	App.sphericalLook( 45, 20, 10 );
    Debug = await useVisualDebug( App );

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // SETUP
    Ref.cube = facedCube();
    Ref.cube.position.set( 0, 1, 0 );
    App.scene.add( Ref.cube );

    Ref.act = new ActionManager( App.scene, App.camera, App.renderer, App.camCtrl )
        .addAction( 'lineRay', new LineRayAction() );

        console.log( App.camCtrl );

    
    startLineRay();

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // App.createRenderLoop( onPreRender ).start();
    App.renderLoop();
    buildUI();
});

function onPreRender( dt, et ){}

window.addEventListener( 'pointerdown', e=>{
    // if( !e.shiftKey ) return;

    // // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // // Compute the Ray and visually draw a line
    // const ray = from3JSScreenProjection( new Ray(), e.layerX, e.layerY );
    // Debug.ln.reset().add( ray.posStart, ray.posEnd, 0x00ffff );

    // // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // const obb     = Ref.rb.collider;
    // const results = new RayObbResult();
    // if( intersectObb( ray, obb.center, obb.xAxis, obb.yAxis, obb.zAxis, obb.halfLen, results ) ){
        
    //     Ref.rb.applyForce( ray.direction.scale( Ref.rayStrength ), results.posEntry );

    //     // const tmp = new Vec3();
    //     // Debug.pnt.add( results.posEntry, 0x00ff00, 3 );
    //     // Debug.pnt.add( results.posExit,  0xff0000, 3 );

    //     // console.log( "Results", results );
    //     // console.log( "OBB", obb.center, obb.xAxis, obb.yAxis, obb.zAxis, obb.halfLen );
    // }
} );

async function buildUI(){
    appendGithubLink( false );
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    const p = new Pane();
    p.registerPlugin( TweakpaneEssentials );
    // p.on( 'change', e=>{
    //     switch( e.target.key ){
    //         case 'attach'   : Ref.rb.constraint.active = e.value; break;
    //     }
    // });
    
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    const f = p.addFolder({ title: 'Main', expanded: true });
    // f.addBinding( Ref, 'attach', { label: 'Anchor' } );

    const actions = [ {t:'LineRay', v:'lineRay'}, {t:'misc', v:'misc'}, ];
    f.addBinding( Ref, 'action', {
            view        : 'radiogrid',
            groupName   : 'actionName',
            label       : 'Actions',
            size        : [ 1, actions.length ],
            cells       : ( x, y ) =>{ 
                return {
                    title: actions[y * 1 + x].t,
                    value: actions[y * 1 + x].v,
                }
            },
        })
        .on( 'change', e => {
            console.log(e);
            switch( e.value ){
                case 'lineRay': startLineRay(); return;
            }
        });

    // // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // const f2 = p.addFolder({ title: 'Ray Caster ( Hold Shift )', expanded: true });
    // f2.addBinding( Ref, 'rayStrength', { min: 0, max: 100, step:5, label: 'Strength' } );

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    Ref.pane = p;
}

function startLineRay(){
    const DIST  = 5;    // Distance from point to move fwd & back
    
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Random rotation
    const q = new Quat().fromPolar(
        180 * ( Math.random() * 2 - 1 ),
        90 * ( Math.random() * 2 - 1 ),
    );

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Compute start and end pos of a segment
    const pos   = new Vec3( Ref.cube.position.toArray() );
    const fwd   = new Vec3().fromQuat( q );
    const sPos  = pos.clone().scaleThenAdd( DIST, fwd );
    const ePos  = pos.clone().scaleThenAdd( DIST, fwd.negate() );

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // DEBUG
    // Debug.pnt.add( sPos, 0x00ff00, 3 );
    // Debug.pnt.add( ePos, 0xff0000, 3 );
    // Debug.ln.add( sPos, ePos, 0x00ff00 );
    
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    const props = {
        startPos    : sPos,
        endPos      : ePos,
    };

    Ref.act.useAction( 'lineRay', new LineRayPreview(), Ref.cube, props );
}

// #endregion

// #region ACTION MANAGER

class ActionManager{
    // #region MAIN
    renderer    = null;
    scene       = null;
    camera      = null;
    camCtrl     = null;
    
    active      = true;
    dragging    = false;

    object      = null;
    action      = null;
    preview     = null;

    actions     = {};

    dynLines    = new DynLinesMesh();       // Reusable way to generate lines
    dynPoints   = new ShapePointsMesh();
    ray         = new Ray();   

    constructor( scene, camera, renderer, camCtrl ){
        this.renderer   = renderer ;
        this.scene      = scene;
        this.camera     = camera;
        this.camCtrl    = camCtrl;
        
        this.startEvents();

        this.scene.add( this.dynLines );
        this.scene.add( this.dynPoints );
    }
    // #endregion

    getObjectPos(){ return this.object ? this.object.position.toArray() : [0,0,0]; }
    setObjectPos( v ){ if( this.object ) this.object.position.fromArray( v ); }

    // #region EVENT HANDLERS & METHODS
    startEvents(){
        const c = this.renderer.domElement;
        c.addEventListener( 'pointerdown',   this.onPointerDown );
        c.addEventListener( 'pointermove',   this.onPointerMove );
        c.addEventListener( 'pointerup',     this.onPointerUp );
        c.addEventListener( 'pointercancel', this.onPointerCancel );
        return this;
    }

    disableEvents(){
        const c = this.renderer.domElement;
        c.removeEventListener( 'pointerdown',   this.onPointerDown );
        c.removeEventListener( 'pointermove',   this.onPointerMove );
        c.removeEventListener( 'pointerup',     this.onPointerUp );
        c.removeEventListener( 'pointercancel', this.onPointerCancel );
        return this;
    }

    onPointerDown = e=>{
        // this.canvas.setPointerCapture( e.pointerId );
        if( !this.active || !this.action ) return;

        // Check if dragging action will started
        if( this.action.onDown( this, e ) ){
            this.dragging           = true;
            this.camCtrl.enabled    = false;
            this.renderer.domElement.setPointerCapture( e.pointerId );
            this.preview.render( this );
        }

        console.log( "PntDown" );
        // from3JSScreenProjection( ray, xMouse, yMouse )
    }

    onPointerMove = e=>{

        if( this.dragging && this.action.onMove( this, e ) ){
            this.preview.render( this );
        }

    }

    onPointerUp = e=>{
        // this.canvas.releasePointerCapture( e.pointerId );
        console.log( "PntUp" );

        if( this.dragging ){
            if( this.action?.onUp( this, e ) ) this.preview.render( this );

            this.dragging           = false;
            this.camCtrl.enabled    = true;
            this.renderer.domElement.releasePointerCapture( e.pointerId );
        }
    }

    onPointerCancel = e=>{
        console.log( 'PointerCancel' );

        if( this.dragging ){
            this.dragging           = false;
            this.camCtrl.enabled    = true;
            this.renderer.domElement.releasePointerCapture( e.pointerId );
        }
    }
    // #endregion

    // #region ACTION MANAGEMENT
    addAction( name, o ){
        this.actions[ name ] = o;
        return this;
    }

    useAction( name, prev, obj, props={} ){
        if( this.action ){}
        if( this.preview ){}

        this.action     = this.actions[ name ];
        this.preview    = prev;
        this.object     = obj;

        this.action.init( props );
        this.preview
            .init( this, this.action )
            .render( this );

        return this;
    }

    clearAction(){
        this.action     = null;
        this.preview    = null;
        this.object     = null;
        return this;
    }
    // #endregion

    // #region RAY CASTING
    getRayFromEvent( e ){
        const size      = new THREE.Vector2();
        const proj      = this.camera.projectionMatrix.toArray();    // Need Projection Matrix
        const camWorld  = this.camera.matrixWorld.toArray();         // World Space Transform of Camera
        this.renderer.getSize( size );                               // Need Size of Canvas

        // Setup Ray
        return this.ray.fromScreenProjection( e.layerX, e.layerY, size.x, size.y, proj, camWorld );
    }
    // #endregion
}

// #endregion

// #region RAY CASTING

// function from3JSScreenProjection( ray, xMouse, yMouse ){
//     const size      = new THREE.Vector2();
//     const proj      = App.camera.projectionMatrix.toArray();    // Need Projection Matrix
//     const camWorld  = App.camera.matrixWorld.toArray();         // World Space Transform of Camera
//     App.renderer.getSize( size );                               // Need Size of Canvas

//     // Setup Ray
//     ray.fromScreenProjection( xMouse, yMouse, size.x, size.y, proj, camWorld );
//     return ray;
// }

class Ray{
    // #region MAIN
    posStart    = new Vec3();   // Origin
    posEnd      = new Vec3();   // 
    direction   = new Vec3();   // Direction from Start to End
    vecLength   = new Vec3();   // Vector Length between start to end
    // #endregion

    // #region SETUP
    fromEndPoints( a, b ){
        this.posStart.copy( a );                    // Starting Point of the Ray
        this.posEnd.copy( b );                      // The absolute end of the ray
        this.vecLength.fromSub( b, a );             // Vector Length
        this.direction.fromNorm( this.vecLength );  // Normalized Vector Length 
        return this;
    }

    fromScreenProjection( x, y, w, h, projMatrix, camMatrix ){
        // http://antongerdelan.net/opengl/raycasting.html
        // Normalize Device Coordinate
        const nx  = x / w * 2 - 1;
        const ny  = 1 - y / h * 2;

        // inverseWorldMatrix = invert( ProjectionMatrix * ViewMatrix ) OR
        // inverseWorldMatrix = localMatrix * invert( ProjectionMatrix ) 
        // const invMatrix = mat4.invert( projMatrix )
        // mat4.mul( camMatrix, invMatrix, invMatrix );
        const invMatrix = new Mat4().fromInvert( projMatrix ).pmul( camMatrix );
        
        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        // https://stackoverflow.com/questions/20140711/picking-in-3d-with-ray-tracing-using-ninevehgl-or-opengl-i-phone/20143963#20143963
        // Clip Cords would be [nx,ny,-1,1];
        const clipNear   = [ nx, ny, -1, 1 ];
        const clipFar    = [ nx, ny, 1, 1 ];

        // using 4d Homogeneous Clip Coordinates
        invMatrix.transformVec4( clipNear );
        invMatrix.transformVec4( clipFar );

        // Normalize by using W component
        for( let i=0; i < 3; i++){
            clipNear[ i ] /= clipNear[ 3 ];
            clipFar [ i ] /= clipFar [ 3 ];
        }

        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        // Final Compute
        this.posStart.copy( clipNear );                         // Starting Point of the Ray
        this.posEnd.copy( clipFar );                            // The absolute end of the ray
        this.vecLength.fromSub( this.posEnd, this.posStart );   // Vector Length
        this.direction.fromNorm( this.vecLength );              // Normalized Vector Length
        return this;
    }
    // #endregion

    // #region GETTERS / SETTERS
    /** Get position of the ray from T Scale of VecLen */
    posAt( t, out = [0,0,0] ){
        // RayVecLen * t + RayOrigin
        // also works lerp( RayOrigin, RayEnd, t )
        out[ 0 ] = this.vecLength[ 0 ] * t + this.posStart[ 0 ];
        out[ 1 ] = this.vecLength[ 1 ] * t + this.posStart[ 1 ];
        out[ 2 ] = this.vecLength[ 2 ] * t + this.posStart[ 2 ];
        return out;
    }

    /** Get position of the ray from distance from origin */
    directionAt( len, out = [0,0,0] ){
        out[ 0 ] = this.direction[ 0 ] * len + this.posStart[ 0 ];
        out[ 1 ] = this.direction[ 1 ] * len + this.posStart[ 1 ];
        out[ 2 ] = this.direction[ 2 ] * len + this.posStart[ 2 ];        
        return out;
    }
    // #endregion

    // #region OPS
    transformMat4( m ){
        this.fromEndPoints( 
            m.transformVec3( this.posStart, [0,0,0] ), 
            m.transformVec3( this.posEnd,   [0,0,0] ),
        );
        return this;
    }
    // #endregion
}

class NearSegmentResult{
    segPosition = [0,0,0];
    rayPosition = [0,0,0];
    distanceSq  = 0;
    distance    = 0;
}

/** Returns [ T of Segment, T of RayLen ] */
function nearSegment( ray, p0, p1, results=null){
    // http://geomalgorithms.com/a07-_distance.html
    const u = new Vec3( p1 ).sub( p0 );
    const v = ray.vecLength;
    const w = new Vec3( p0 ).sub( ray.posStart );
    const a = Vec3.dot( u, u ); // always >= 0
    const b = Vec3.dot( u, v );
    const c = Vec3.dot( v, v ); // always >= 0
    const d = Vec3.dot( u, w );
    const e = Vec3.dot( v, w );
    const D = a * c - b * b;    // always >= 0

    let tU = 0; // T Of Segment 
    let tV = 0; // T Of Ray

    // Compute the line parameters of the two closest points
    if( D < 0.000001 ){	            // the lines are almost parallel
        tU = 0.0;
        tV = ( b > c ? d/b : e/c ); // use the largest denominator
    }else{
        tU = ( b*e - c*d ) / D;
        tV = ( a*e - b*d ) / D;
    }

    if( tU < 0 || tU > 1 || tV < 0 || tV > 1 ) return null;
    
    // Segment Position : u.scale( tU ).add( p0 )
    // Ray Position :     v.scale( tV ).add( this.origin ) ];
    if( results ){
        // Get SegPostion by lerping the two end points
        const ti = 1 - tU;
        results.segPosition[ 0 ] = p0[0] * ti + p1[0] * tU;
        results.segPosition[ 1 ] = p0[1] * ti + p1[1] * tU;
        results.segPosition[ 2 ] = p0[2] * ti + p1[2] * tU;
        
        // Get Ray position by using its T Lerp value as well
        ray.posAt( tV, results.rayPosition );
        
        // Distances for intersection testing
        results.distanceSq = Vec3.distSqr( results.segPosition, results.rayPosition );
        results.distance   = Math.sqrt( results.distanceSq );
    }

    return [ tU, tV ]; // The Lerp T values for Segment & Ray
}

// #endregion

// #region ACTIONS

class LineRayAction{ 
    hitRange = 0.3;

    startPos = new Vec3();
    endPos   = new Vec3();
    initPos  = new Vec3();
    offset   = new Vec3();
    pos      = new Vec3();

    results  = new NearSegmentResult();

    constructor(){}

    init( props ){
        this.startPos.copy( props.startPos );
        this.endPos.copy( props.endPos );
        return this;
    }

    onDown( mgt, e ){
        const ray = mgt.getRayFromEvent( e );
        // Debug.ln.add( ray.posStart, ray.posEnd, 0x00ffff );

        if( nearSegment( ray, this.endPos, this.startPos, this.results )
            && this.results.distance <= this.hitRange ){

            this.initPos.copy( this.results.segPosition );
            this.offset.fromSub( mgt.getObjectPos(), this.initPos );

            return true;
        }

        return false;
    }

    onMove( mgt, e ){
        const ray = mgt.getRayFromEvent( e );
        if( nearSegment( ray, this.endPos, this.startPos, this.results ) ){            

            this.pos.fromAdd( this.results.segPosition, this.offset );

            Debug.pnt.reset();
            Debug.pnt.add( this.results.segPosition, 0xff00ff, 5 );
            Debug.pnt.add( this.pos, 0xffffff, 5 );

            const v = new Vec3().fromAdd( this.offset, this.initPos );
            Debug.pnt.add( v, 0x0000ff, 5 );

            mgt.setObjectPos( this.pos );
            return true;
        }

        return false;
    }

    onUp( mgt, e ){ return true; }
}

// https://github.com/sketchpunklabs/gizmos/blob/main/src/util/MouseHandlers.ts
// https://github.com/sketchpunklabs/gizmos/blob/main/src/actions/LineMovement.ts
// https://github.com/sketchpunklabs/gizmos/blob/main/src/actions/PlaneMovement.ts
// https://github.com/sketchpunklabs/gizmos/blob/main/src/gizmos/RotationGizmoV2.ts
// https://github.com/sketchpunklabs/gizmos/blob/main/src/gizmos/TranslateGizmo.ts

// #endregion 

// #region PREVIEWS

// https://github.com/sketchpunklabs/gizmos/blob/main/src/actions/LineMovementRender.ts
// https://github.com/sketchpunklabs/gizmos/blob/main/src/actions/AngleMovementRender.ts
// https://github.com/sketchpunklabs/gizmos/blob/main/src/render/AngleViewMaterial.ts
// https://github.com/sketchpunk/tmp_proto/blob/main/poly3deditor/index.html#L1107

class LineRayPreview{
    action = null;
    constructor(){}

    init( mgt, action ){
        this.action = action;
        return this;
    }

    render( mgt ){
        const act = this.action;
        const pnt = mgt.dynPoints.reset();
        const ln  = mgt.dynLines.reset();
        
        pnt.add( act.startPos, 0x00ff00 );
        pnt.add( act.endPos, 0xff0000 );
        if( mgt.dragging ) pnt.add( act.initPos, 0x00ffff );

        ln.add( act.startPos, act.endPos, 0x00ff00, 0xff0000 );
    }
}

// #endregion

// #region MATHS

class Vec3 extends Array{
    constructor( v=null ){
        super( 3 );
        if( v?.length === 3 ) this.copy( v );
        else                  this.zero();
    }

    // #region SETTERS
    zero(){
        this[0] = 0;
        this[1] = 0;
        this[2] = 0;
        return this;
    }

    copy( v ){
        this[0] = v[0];
        this[1] = v[1];
        this[2] = v[2];
        return this;
    }

    xyz( x, y, z ){
        this[0] = x;
        this[1] = y;
        this[2] = z;
        return this;
    }
    // #endregion

    // #region GETTERS
    get len(){ return Math.sqrt( this[ 0 ]**2 + this[ 1 ]**2 + this[ 2 ]**2 ); }
    get lenSqr(){ return  this[ 0 ]**2 + this[ 1 ]**2 + this[ 2 ]**2; }

    clone(){ return new Vec3( this ); }
    // #endregion

    // #region FROM OPS
    fromAdd( a, b ){
        this[ 0 ] = a[ 0 ] + b[ 0 ];
        this[ 1 ] = a[ 1 ] + b[ 1 ];
        this[ 2 ] = a[ 2 ] + b[ 2 ];
        return this;
    }

    fromSub( a, b ){
        this[ 0 ] = a[ 0 ] - b[ 0 ];
        this[ 1 ] = a[ 1 ] - b[ 1 ];
        this[ 2 ] = a[ 2 ] - b[ 2 ];
        return this;
    }
    // fromScale( v, s ){
    //     this[ 0 ] = v[0] * s;
    //     this[ 1 ] = v[1] * s;
    //     this[ 2 ] = v[2] * s;
    //     return this;
    // }

    fromNorm( v ){
        let mag = Math.sqrt( v[ 0 ]**2 + v[ 1 ]**2 + v[ 2 ]**2 );
        if( mag == 0 ) return this;

        mag       = 1 / mag;
        this[ 0 ] = v[ 0 ] * mag;
        this[ 1 ] = v[ 1 ] * mag;
        this[ 2 ] = v[ 2 ] * mag;
        return this;
    }

    fromCross( a, b ){
        const ax = a[0], ay = a[1], az = a[2],
              bx = b[0], by = b[1], bz = b[2];

        this[ 0 ] = ay * bz - az * by;
        this[ 1 ] = az * bx - ax * bz;
        this[ 2 ] = ax * by - ay * bx;
        return this;
    }

    fromQuat( q, v=[0,0,1] ){
        const qx = q[0], qy = q[1], qz = q[2], qw = q[3],
              vx = v[0], vy = v[1], vz = v[2],
              x1 = qy * vz - qz * vy,
              y1 = qz * vx - qx * vz,
              z1 = qx * vy - qy * vx,
              x2 = qw * x1 + qy * z1 - qz * y1,
              y2 = qw * y1 + qz * x1 - qx * z1,
              z2 = qw * z1 + qx * y1 - qy * x1;
        this[ 0 ] = vx + 2 * x2;
        this[ 1 ] = vy + 2 * y2;
        this[ 2 ] = vz + 2 * z2;
        return this;
    }
    // #endregion

    // #region OPERATORS
    add( a ){
        this[ 0 ] += a[ 0 ];
        this[ 1 ] += a[ 1 ];
        this[ 2 ] += a[ 2 ];
        return this;
    }

    sub( v ){
        this[ 0 ] -= v[ 0 ];
        this[ 1 ] -= v[ 1 ];
        this[ 2 ] -= v[ 2 ];
        return this;
    }

    scale( v ){
        this[ 0 ] *= v;
        this[ 1 ] *= v;
        this[ 2 ] *= v;
        return this;
    }

    invScale( v ){
        this[ 0 ] /= v;
        this[ 1 ] /= v;
        this[ 2 ] /= v;
        return this;
    }

    scaleThenAdd( s, v ){
        this[ 0 ] += v[0] * s;
        this[ 1 ] += v[1] * s;
        this[ 2 ] += v[2] * s;
        return this;
    }

    cross( b ){
        const ax = this[0], ay = this[1], az = this[2],
              bx = b[0],    by = b[1],    bz = b[2];

        this[ 0 ] = ay * bz - az * by;
        this[ 1 ] = az * bx - ax * bz;
        this[ 2 ] = ax * by - ay * bx;
        return this;
    }
    
    norm(){
        let mag = Math.sqrt( this[0]**2 + this[1]**2 + this[2]**2 );
        if( mag != 0 ){
            mag        = 1 / mag;
            this[ 0 ] *= mag;
            this[ 1 ] *= mag;
            this[ 2 ] *= mag;
        }
        return this;
    }

    negate(){
        this[ 0 ] = -this[ 0 ];
        this[ 1 ] = -this[ 1 ];
        this[ 2 ] = -this[ 2 ];
        return this;
    }
    // #endregion

    // #region STATIC OPS
    static len( a ){ return Math.sqrt( a[ 0 ]**2 + a[ 1 ]**2 + a[ 2 ]** 2 ); }
    static lenSqr( a ){ return a[ 0 ]**2 + a[ 1 ]**2 + a[ 2 ]** 2; }

    static dist( a, b ){ return Math.sqrt( (a[ 0 ]-b[ 0 ]) ** 2 + (a[ 1 ]-b[ 1 ]) ** 2 + (a[ 2 ]-b[ 2 ]) ** 2 ); }
    static distSqr( a, b ){ return (a[ 0 ]-b[ 0 ]) ** 2 + (a[ 1 ]-b[ 1 ]) ** 2 + (a[ 2 ]-b[ 2 ]) ** 2; }

    static dot( a, b ) { return a[ 0 ] * b[ 0 ] + a[ 1 ] * b[ 1 ] + a[ 2 ] * b[ 2 ]; }
    static cross( a, b, out=new Vec3() ){
        const ax = a[0], ay = a[1], az = a[2],
              bx = b[0], by = b[1], bz = b[2];

        out[ 0 ] = ay * bz - az * by;
        out[ 1 ] = az * bx - ax * bz;
        out[ 2 ] = ax * by - ay * bx;
        return out;
    }
    // #endregion
}

class Quat extends Array{
    constructor( v=null ){
        super( 4 );
        if( v?.length === 4 ) this.copy( v );
        else                  this.identity();
    }

    // #region SETTERS
    identity(){
        this[0] = 0;
        this[1] = 0;
        this[2] = 0;
        this[3] = 1;
        return this;
    }

    copy( v ){
        this[0] = v[0];
        this[1] = v[1];
        this[2] = v[2];
        this[3] = v[3];
        return this;
    }
    // #endregion

    // #region OPERATIONS
    /** Multiple Quaternion onto this Quaternion */
    mul( q ){
        const ax = this[0], ay = this[1], az = this[2], aw = this[3],
              bx = q[0],    by = q[1],    bz = q[2],    bw = q[3];
        this[ 0 ] = ax * bw + aw * bx + ay * bz - az * by;
        this[ 1 ] = ay * bw + aw * by + az * bx - ax * bz;
        this[ 2 ] = az * bw + aw * bz + ax * by - ay * bx;
        this[ 3 ] = aw * bw - ax * bx - ay * by - az * bz;
        return this;
    }

    /** PreMultiple Quaternions onto this Quaternion */
    pmul( q ){
        const ax = q[0],    ay  = q[1],     az = q[2],    aw = q[3],
              bx = this[0], by  = this[1],  bz = this[2], bw = this[3];
        this[ 0 ] = ax * bw + aw * bx + ay * bz - az * by;
        this[ 1 ] = ay * bw + aw * by + az * bx - ax * bz;
        this[ 2 ] = az * bw + aw * bz + ax * by - ay * bx;
        this[ 3 ] = aw * bw - ax * bx - ay * by - az * bz;
        return this;
    }

    norm(){
        let len =  this[0]**2 + this[1]**2 + this[2]**2 + this[3]**2;
        if( len > 0 ){
            len = 1 / Math.sqrt( len );
            this[ 0 ] *= len;
            this[ 1 ] *= len;
            this[ 2 ] *= len;
            this[ 3 ] *= len;
        }
        return this;
    }

    invert(){
        const a0  = this[ 0 ],
              a1  = this[ 1 ],
              a2  = this[ 2 ],
              a3  = this[ 3 ],
              dot = a0*a0 + a1*a1 + a2*a2 + a3*a3;
        
        if(dot == 0){ this[0] = this[1] = this[2] = this[3] = 0; return this }

        const invDot = 1.0 / dot; // let invDot = dot ? 1.0/dot : 0;
        this[ 0 ]    = -a0 * invDot;
        this[ 1 ]    = -a1 * invDot;
        this[ 2 ]    = -a2 * invDot;
        this[ 3 ]    =  a3 * invDot;
        return this;
    }
    // #endregion

    // #region FROM OPS
    fromPolar( lon, lat, up=null ){
        lat = Math.max( Math.min( lat, 89.999999 ), -89.999999 ); // Clamp lat, going to 90+ makes things spring around.

        const phi   = ( 90 - lat ) * 0.01745329251, // PI / 180
              theta = lon * 0.01745329251,
              phi_s	= Math.sin( phi ),
              v    = [
                -( phi_s * Math.sin( theta ) ),
                Math.cos( phi ),
                phi_s * Math.cos( theta )
            ];

        this.fromLook( v, up || [0,1,0] );
        return this;
    }

    fromLook( dir, up = [0,1,0] ){
        // Ported to JS from C# example at https://pastebin.com/ubATCxJY
        // TODO, if Dir and Up are equal, a roll happends. Need to find a way to fix this.
        const zAxis	= new Vec3( dir ).norm();                       // Forward
        const xAxis = new Vec3().fromCross( up, zAxis ).norm();     // Right
        const yAxis = new Vec3().fromCross( zAxis, xAxis ).norm();  // Up

        // fromAxis - Mat3 to Quat
        const m00 = xAxis[0], m01 = xAxis[1], m02 = xAxis[2],
              m10 = yAxis[0], m11 = yAxis[1], m12 = yAxis[2],
              m20 = zAxis[0], m21 = zAxis[1], m22 = zAxis[2],
              t   = m00 + m11 + m22;

        let x, y, z, w, s;

        if(t > 0.0){
            s = Math.sqrt(t + 1.0);
            w = s * 0.5 ; // |w| >= 0.5
            s = 0.5 / s;
            x = (m12 - m21) * s;
            y = (m20 - m02) * s;
            z = (m01 - m10) * s;
        }else if((m00 >= m11) && (m00 >= m22)){
            s = Math.sqrt(1.0 + m00 - m11 - m22);
            x = 0.5 * s;// |x| >= 0.5
            s = 0.5 / s;
            y = (m01 + m10) * s;
            z = (m02 + m20) * s;
            w = (m12 - m21) * s;
        }else if(m11 > m22){
            s = Math.sqrt(1.0 + m11 - m00 - m22);
            y = 0.5 * s; // |y| >= 0.5
            s = 0.5 / s;
            x = (m10 + m01) * s;
            z = (m21 + m12) * s;
            w = (m20 - m02) * s;
        }else{
            s = Math.sqrt(1.0 + m22 - m00 - m11);
            z = 0.5 * s; // |z| >= 0.5
            s = 0.5 / s;
            x = (m20 + m02) * s;
            y = (m21 + m12) * s;
            w = (m01 - m10) * s;
        }

        this[ 0 ] = x;
        this[ 1 ] = y;
        this[ 2 ] = z;
        this[ 3 ] = w;
        return this;
    }
    // #endregion

    // #region CONVERT
    fromMat3( m ){
        // https://github.com/toji/gl-matrix/blob/master/src/gl-matrix/quat.js#L305
        // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes
        // article "Quat Calculus and Fast Animation".
        let fRoot;
        const fTrace = m[0] + m[4] + m[8];

        if( fTrace > 0.0 ){
            // |w| > 1/2, may as well choose w > 1/2
            fRoot	= Math.sqrt( fTrace + 1.0 );  // 2w
            this[3]	= 0.5 * fRoot;
            
            fRoot	= 0.5 / fRoot;  // 1/(4w)
            this[0]	= (m[5]-m[7])*fRoot;
            this[1]	= (m[6]-m[2])*fRoot;
            this[2]	= (m[1]-m[3])*fRoot;
        }else{
            // |w| <= 1/2
            let i = 0;

            if ( m[4] > m[0] )		i = 1;
            if ( m[8] > m[i*3+i] )	i = 2;
            
            const j = (i+1) % 3;
            const k = (i+2) % 3;

            fRoot	= Math.sqrt( m[i*3+i] - m[j*3+j] - m[k*3+k] + 1.0);
            this[ i ]	= 0.5 * fRoot;

            fRoot	= 0.5 / fRoot;
            this[ 3 ]	= ( m[j*3+k] - m[k*3+j] ) * fRoot;
            this[ j ]	= ( m[j*3+i] + m[i*3+j] ) * fRoot;
            this[ k ]	= ( m[k*3+i] + m[i*3+k] ) * fRoot;
        }
        return this;
    }
    // #endregion
}

class Mat4 extends Array{
    // #region CONSTRUCTOR
    constructor(){ 
        super(16);
        this[0]  = 1;
        this[1]  = 0;
        this[2]  = 0;
        this[3]  = 0;

        this[4]  = 0;
        this[5]  = 1;
        this[6]  = 0;
        this[7]  = 0;

        this[8]  = 0;
        this[9]  = 0;
        this[10] = 1;
        this[11] = 0;

        this[12] = 0;
        this[13] = 0;
        this[14] = 0;
        this[15] = 1;
    }
    // #endregion

    // #region FROM OPS
    fromInvert( mat ){
        const a00 = mat[0],  a01 = mat[1],  a02 = mat[2],  a03 = mat[3],
              a10 = mat[4],  a11 = mat[5],  a12 = mat[6],  a13 = mat[7],
              a20 = mat[8],  a21 = mat[9],  a22 = mat[10], a23 = mat[11],
              a30 = mat[12], a31 = mat[13], a32 = mat[14], a33 = mat[15],

              b00 = a00 * a11 - a01 * a10,
              b01 = a00 * a12 - a02 * a10,
              b02 = a00 * a13 - a03 * a10,
              b03 = a01 * a12 - a02 * a11,
              b04 = a01 * a13 - a03 * a11,
              b05 = a02 * a13 - a03 * a12,
              b06 = a20 * a31 - a21 * a30,
              b07 = a20 * a32 - a22 * a30,
              b08 = a20 * a33 - a23 * a30,
              b09 = a21 * a32 - a22 * a31,
              b10 = a21 * a33 - a23 * a31,
              b11 = a22 * a33 - a23 * a32;

        let det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06; // Calculate the determinant

        if( !det ) return this;
        det = 1.0 / det;

        this[0]  = (a11 * b11 - a12 * b10 + a13 * b09) * det;
        this[1]  = (a02 * b10 - a01 * b11 - a03 * b09) * det;
        this[2]  = (a31 * b05 - a32 * b04 + a33 * b03) * det;
        this[3]  = (a22 * b04 - a21 * b05 - a23 * b03) * det;
        this[4]  = (a12 * b08 - a10 * b11 - a13 * b07) * det;
        this[5]  = (a00 * b11 - a02 * b08 + a03 * b07) * det;
        this[6]  = (a32 * b02 - a30 * b05 - a33 * b01) * det;
        this[7]  = (a20 * b05 - a22 * b02 + a23 * b01) * det;
        this[8]  = (a10 * b10 - a11 * b08 + a13 * b06) * det;
        this[9]  = (a01 * b08 - a00 * b10 - a03 * b06) * det;
        this[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
        this[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
        this[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
        this[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
        this[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
        this[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;

        return this;
    }
    // #endregion

    // #region OPERATIONS
    mul( b ){ 
        const   a00 = this[0],	a01 = this[1],	a02 = this[2],	a03 = this[3],
                a10 = this[4],	a11 = this[5],	a12 = this[6],	a13 = this[7],
                a20 = this[8],	a21 = this[9],	a22 = this[10],	a23 = this[11],
                a30 = this[12],	a31 = this[13],	a32 = this[14],	a33 = this[15];

        // Cache only the current line of the second matrix
        let b0  = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
        this[0] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
        this[1] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
        this[2] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
        this[3] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

        b0 = b[4]; b1 = b[5]; b2 = b[6]; b3 = b[7];
        this[4] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
        this[5] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
        this[6] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
        this[7] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

        b0 = b[8]; b1 = b[9]; b2 = b[10]; b3 = b[11];
        this[8] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
        this[9] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
        this[10] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
        this[11] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

        b0 = b[12]; b1 = b[13]; b2 = b[14]; b3 = b[15];
        this[12] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
        this[13] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
        this[14] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
        this[15] = b0*a03 + b1*a13 + b2*a23 + b3*a33;
        return this;	
    }

    pmul( b ){ 
        const   a00 = b[0],	 a01 = b[1],  a02 = b[2],  a03 = b[3],
                a10 = b[4],  a11 = b[5],  a12 = b[6],  a13 = b[7],
                a20 = b[8],  a21 = b[9],  a22 = b[10], a23 = b[11],
                a30 = b[12], a31 = b[13], a32 = b[14], a33 = b[15];

        // Cache only the current line of the second matrix
        let b0  = this[0], b1 = this[1], b2 = this[2], b3 = this[3];
        this[0] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
        this[1] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
        this[2] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
        this[3] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

        b0 = this[4]; b1 = this[5]; b2 = this[6]; b3 = this[7];
        this[4] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
        this[5] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
        this[6] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
        this[7] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

        b0 = this[8]; b1 = this[9]; b2 = this[10]; b3 = this[11];
        this[8]  = b0*a00 + b1*a10 + b2*a20 + b3*a30;
        this[9]  = b0*a01 + b1*a11 + b2*a21 + b3*a31;
        this[10] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
        this[11] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

        b0 = this[12]; b1 = this[13]; b2 = this[14]; b3 = this[15];
        this[12] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
        this[13] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
        this[14] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
        this[15] = b0*a03 + b1*a13 + b2*a23 + b3*a33;
        return this;	
    }
    // #endregion

    // #region TRANSFORMS
    transformVec3( v, out ){
        const x = v[0], y = v[1], z = v[2];
        out    = out || v;
        out[0] = this[0] * x + this[4] * y + this[8]  * z + this[12];
        out[1] = this[1] * x + this[5] * y + this[9]  * z + this[13];
        out[2] = this[2] * x + this[6] * y + this[10] * z + this[14];
        return out;
    }
        
    transformVec4( v, out ){
        const x = v[0], y = v[1], z = v[2], w = v[3];
        out    = out || v;
        out[0] = this[0] * x + this[4] * y + this[8]  * z + this[12] * w;
        out[1] = this[1] * x + this[5] * y + this[9]  * z + this[13] * w;
        out[2] = this[2] * x + this[6] * y + this[10] * z + this[14] * w;
        out[3] = this[3] * x + this[7] * y + this[11] * z + this[15] * w;
        return out;
    }
    // #endregion
}

// #endregion

</script></body></html>