<!DOCTYPE html><html lang="en"><head><title></title></head>
<style>canvas{ display:block; } body, html { padding:0px; margin:0px; width:100%; height:100%; }</style>
<body><script src="../../../import-map.js"></script><script type="module">
// #region IMPORTS
    import useThreeWebGL2, { THREE, useDarkScene, useVisualDebug } from '@lib/useThreeWebGL2.js';

    import Vec3         from '@lib/maths/Vec3.js';
    import Quat         from '@lib/maths/Quat.js';
// #endregion

// #region MAIN
    let App   = useDarkScene( useThreeWebGL2() );
    let Debug = {};
    let Ref   = {};

    window.addEventListener( 'load', async ()=>{
    	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    	App.sphericalLook( 0, 20, 2, [0,0.5,0] );
        Debug = await useVisualDebug( App );

        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        const geo  = new THREE.CapsuleGeometry( 0.25, 0.5, 2, 8 );
        geo.translate( 0, 0.5, 0 ); // Height * 0.5 + radius

        const mat  = new THREE.MeshBasicMaterial( { color: 0x707070,  wireframe: true } );
        const mesh = new THREE.Mesh( geo, mat );
        App.scene.add( mesh );

        // mesh.position.y = -1.2;
        // mesh.position.x = -0.2;
        mesh.rotation.x = Math.PI * -0.75;

        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        const cap = new Capsule().fromGround( 0.25, 1 )
            .quat( mesh.quaternion.toArray() )
            .translate( mesh.position.toArray() );

        Debug.pnt.add( cap.posA, 0x00ff00, 1 );
        Debug.pnt.add( cap.posB, 0xff0000, 1 );

        const pln = new Plane();
        // pln.pos[1] = 0.2;
        pln._calc();

        const result = {};
        if( hit_capsule_plane( cap, pln, result ) ){
            console.log( 'hit', result );
            if( result.depth !== 0 ){
                mesh.position.x += result.separation[0];
                mesh.position.y += result.separation[1];
                mesh.position.z += result.separation[2];
            }
        }

        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        App.createRenderLoop( onPreRender ).start();
        // App.renderLoop();
    });

    function onPreRender( dt, et ){

    }
// #endregion

// #region PRIMITIVES
    class Capsule{
        posA    = [0,0,0];
        posB    = [0,1,0];
        radius  = 0.5;
        constructor(){}

        // #region GETTERS / SETTERS
        fromGround( radius=0.5, height=1 ){
            // Zero out XZ
            this.posA[0] = this.posB[0] = 0;
            this.posA[2] = this.posB[2] = 0;

            // Points set vertically
            this.radius  = radius;
            this.posA[1] = radius;
            this.posB[1] = height - radius;
            return this;
        }

        clone(){
            const o     = new Capsule();
            o.posA      = this.posA.slice();
            o.posB      = this.posB.slice();
            o.radius    = this.radius;
            return o;
        }
        // #endregion

        // #region TRANSFORM
        translate( v ){
            this.posA[0] += v[0];
            this.posA[1] += v[1];
            this.posA[2] += v[2];
            this.posB[0] += v[0];
            this.posB[1] += v[1];
            this.posB[2] += v[2];
            return this;
        }

        quat( q ){
            Vec3.applyQuat( this.posA, q, this.posA );
            Vec3.applyQuat( this.posB, q, this.posB );
            return this;
        }
        // #endregion
    }

    class Plane{
        pos     = [0,0,0];
        norm    = [0,1,0];
        k       = 0;
        _calc(){
            const p = this.pos;
            const n = this.norm;
            this.k  = -( n[0]*p[0] + n[1]*p[1] + n[2]*p[2] );
        }
    }
// #endregion

// #region COLLISION TESTS
    function hit_capsule_plane( cap, pln, result=null ){
        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        // Distance of each end point to the plane: dist = dot( pos, planeNorm ) + planeK
        const distA   = Vec3.dot( cap.posA, pln.norm ) + pln.k;
        const distB   = Vec3.dot( cap.posB, pln.norm ) + pln.k;
        const minDist = Math.min( distA, distB );

        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        if( minDist <= cap.radius ){
            if( result ){
                const minPnt  = ( distA < distB )? cap.posA : cap.posB;
                const depth   = cap.radius - minDist;
                const v       = new Vec3();

                result[ 'depth' ]        = depth;
                // separation vector = planeNorm * depth
                result[ 'separation']    = v.fromScale( pln.norm, depth ).slice();
                // contactPos = minPos - ( planeNorm * minDist )
                result[ 'contact' ]      = v.fromScale( pln.norm, minDist ).fromSub( minPnt, v ).slice();
            }

            return true;
        }

        return false;
    }
// #endregion
</script></body></html>
